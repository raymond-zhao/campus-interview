# [字节跳动提前批后端面经](https://www.nowcoder.com/discuss/451296)

## 项目相关

## Spring介绍一下

[Spring原理初探----IOC、AOP](https://www.jianshu.com/p/c403609185a5)

- Spring 是一个开源的，轻量级的JavaEE解决方案，整合了众多优秀的设计模式。最初是由澳大利亚的音乐学博士Rod Johnson开发的，现在的Spring生态已经不限于Spring，还有Spring Cloud、Spring Boot、Spring Data Flow等衍生项目。
2. Spring 框架核心有二，一是 IoC(Inversion of Control) 容器，核心思想是控制反转；二是 AOP(Aspect Oriented Programming)，即切面编程。
3. IoC 是 Spring 的核心，作用是将原先手动创建对象的控制权交给Spring中的IoC容器来管理，由Spring来完成依赖注入，减小了对象间的耦合程度，有利于功能复用。
3. AOP 是指切面编程，可以解决一些OOP不方便解决的问题，常用来进行认证授权、日志记录、异常处理等。AOP 以功能进行划分，对服务顺序执行流程中的不同位置进行横切，完成各服务共同需要实现的功能。
3. 另外还有支持Web的组件Spring MVC，对数据访问的组件Data Access等。

## [SpringMVC工作流程](https://c-catnip.github.io/2019/08/19/%E5%90%8E%E7%AB%AF/SpringMVC/SpringMVC_%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/)

[从SpringMvc源码分析其工作原理](https://juejin.im/post/6844903826000969742)

![SpringMVC工作流程图](https://c-catnip.github.io/2019/08/19/%E5%90%8E%E7%AB%AF/SpringMVC/SpringMVC_%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/SpringMVC%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E5%9B%BE.png)

1. 用户发送请求到 DispatcherServlet
2. DispatcherServlet 收到请求后调用处理器映射器 HandlerMapping
3. 处理器映射器找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet
4. DispatcherServlet 调用 处理器适配器HandlerAdapter
5. 处理器适配器经过适配调用具体的处理器(Controller，也叫后端控制器)
6. Controller执行完成返回ModelAndView
7. HandlerAdapter将Controller执行结果ModelAndView返回给DispatcherServlet
8. DispatcherServlet将ModelAndView传给视图解析器ViewReslover
9. ViewReslover对ModelAndView进行解析后返回具体视图给DispatcherServlet
10. DispatcherServlet根据视图进行渲染，把模型数据填充至request域中
11. 最后DispatcherServlet把处理结果响应给用户

## Spring事务传播

**支持当前事务的情况：**

- **TransactionDefinition.PROPAGATION_REQUIRED：** 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。
- **TransactionDefinition.PROPAGATION_SUPPORTS：** 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。
- **TransactionDefinition.PROPAGATION_MANDATORY：** 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。

**不支持当前事务的情况：**

- **TransactionDefinition.PROPAGATION_REQUIRES_NEW：** 创建一个新的事务，如果当前存在事务，则把当前事务挂起。
- **TransactionDefinition.PROPAGATION_NOT_SUPPORTED：** 以非事务方式运行，如果当前存在事务，则把当前事务挂起。
- **TransactionDefinition.PROPAGATION_NEVER：** 以非事务方式运行，如果当前存在事务，则抛出异常。

**其他情况：**

- **TransactionDefinition.PROPAGATION_NESTED：** 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于**TransactionDefinition.PROPAGATION_REQUIRED**。

---

## 常见注解说一下

推荐阅读：[@Autowired与@Resource区别](https://www.cnblogs.com/think-in-java/p/5474740.html)

```markdown
@Autowired // 只按照类型注入。
@Resource // 按名称匹配，也可按类型匹配。
@ResponseBody
@Controller
@RestController
@RequestMapping
@GetMapping
@PostMapping
@Configuration
@Bean
@Component
@SpringBootApplication
@ComponentScan
// ...
```

## Java用过什么集合框架

- Java中的集合框架可以划分为两类，一类是集合Collection，用来存储同一类型的数据，Collection的子接口又分为List、Set、Queue三种；另一类是Map，用来存储键值对数据。

- Map、HashMap、LinkedHashMap、TreeMap
- List：ArrayList、LinkedList、Stack
- Set：HashSet、LinkedHashSet、TreeSet、Stack、ArrayDeque
- Queue：PriorityQueue

## HashMap源码说一下

（细说，从初始化到put、get、扩容、红黑树、1.8做了哪些优化）

**put(K key, V val)**

  1. 检查Hash桶数组是否为空或者长度为0，如果是的话则进行扩容操作

  2. 根据 key 计算 hash 值，作为桶数组中的索引 i

  3. 检查 table[i] 处是否为空

    3.1 如果为空的话，则创建 Node 结点直接插入
    3.2 如果非空的话，检查 key 是否存在，如果已存在，则为更新操作，直接覆盖
      3.2.1 如果 key 不存在，检查 table[i] 是否是红黑树节点，
      3.2.2 是的话则在红黑树中进行插入
      3.2.3 如果是链表，遍历链表寻找位置插入，此时链表长度不大于8，则进行插入或覆盖。
      3.2.4 如果长度大于 8，则转换为红黑树再插入

  4. 在 put 进值之后，将桶的数据容量+1，检查是否查过阈值需要扩容。

    4.1 如果需要扩容则扩容
    4.2 不需要扩容则结束

**get(K key)**

  1. 根据 key 计算 hash 值，记索引为 i
  2. 检查 table 是否为空、长度是否大于0、并且 table[i] 中的第一个节点是否为空
  3. 如果 table 非空并且 table[i] 的第一个节点非空的话，

    	则比较hash值、key值是否相等，相等的话则查到，直接返回
  4. 如果第一个节点不匹配的话，则检查是否是红黑树节点，是的话则到红黑树中查找，

    	不是红黑树节点的话则到遍历链表结点。接下来无论是在红黑树中还是在链表中，
    	都会对比hash值和key值，如果都匹配的话则说明查找到，返回。
  5. 如果没查到的话，返回空。

**扩容**

1. 先引用保存扩容前的数组
2. 检查旧数组的容量是否已达到最大值，是则将阈值设置为 Integer 的最大值，并直接返回。
3. 否则的话，申请一个新容量的数组，执行 transfer() 方法，具体的是
    3.1 遍历旧的数组，检查每一个桶是否为空，如果不为空的话，先把它保存一份，然后将其置空，
    3.2 接着按保存下来的桶数组的头进行遍历，计算每一个结点在新数组中的位置
    3.3 最后将旧数组中的结点迁移到新数组中对应的位置。
4. 将旧数组的指针指向新数组
5. 计算新的阈值

## ConcurrentHashMap源码看过吗？讲一下吧。

推荐阅读：[ConcurrentHashMap](https://raymond-zhao.top/2020/07/09/2020-07-09-JUC-ConcurrentHashMap/)

首先，ConcurrentHashMap 是由纽约州立大学奥斯威戈分校的计算机科学教授 Doug Lea 编写的，它是 HashMap 的线程安全版本，在源码实现中大量地使用`Unsafe`类的`CAS`操作。

---

初始化方法 `initTable()`

1. 首先检查`tab`是否为空，如果为空的话则尝试去初始化。
2. 检查`sizeCtl`是否小于 0，因为`sizeCtl` 的默认值为`0`，所以最先进入方法的一个或多个线程会尝试使用`CAS`去初始化数组，设置成功的话`sizeCtl=-1`，表示正在初始化，后续的线程将会进入调用`Thread.yield()`方法，由运行态转为就绪态。
3. 在将`sizeCtl`设置为 -1 后，会再次检查 `tab` 是否已被初始化，这是双端检锁的思想，避免`tab`被重复初始化。
4. 此时将会去设置指定容量的 Node 数组，默认为 16，并将成员变量`table`指向新创建的 Node 数组。
5. 接着降回去计算阈值，这里使用`sc=n - (n >>> 2);`，可以保证新的阈值=新容量*0.75。
6. 最后再更新`sizeCtl`，返回初始化后的`tab`。

---

`put(K key, V val)`

1. 检查`k-v`是否为`null`，是的话则抛出`NPE`。
2. 根据 `key` 计算 hash 值。
3. 检查 table 是否已被初始化，如果没有的话将会尝试去初始化，此时允许多个线程去尝试初始化，但是`initTable()`中的`CAS`操作保证了只有一个线程能够初始化成功。
4. 利用 `(n-1) & hash` 计算索引值，然后检查 `table` 中这个位置的首结点是否为空，为空的话则使用`CAS`尝试去设置值，设置成功则跳出。
5. 如果首结点不为空，说明发生了碰撞，这个时候将会使用`synchronized`去加锁头结点，但是不影响`table`中的其他 Node 的工作。接下来将会去判断加锁的头结点是属于链表结点还是红黑树节点。
   1. 如果是链表结点的话， 比较 key 和 hash 是否均相等，如果相等则进行覆盖，如果找到链表尾部 key 都不相等则在尾部进行插入(尾插法)。然后还要检查链表结点数量是否达到了树化阈值，是的话则进行树化。
   2. 如果是红黑树节点的话，则调用红黑树的操作进行节点插入，并进行相应地调整。
6. 如果此时进来的其他线程检查到正在扩容操作的话，将会去协助扩容，减少扩容时间。
7. 最后调用`addCount(1L, binCount)` 方法区近似地估计一下`table`中的总的元素数量。

---

`get(Object key)`

1. 根据 `key` 计算 哈希值
2. 检查`table`是否为空，非空的话检查`table`中根据`key`计算出的索引处的头结点也不为空
   1. 如果这两个检查中有一个为空，则返回`null`。
   2. 否则的话，检查定位到的头结点的 hash 与 key 是否均相等，相等的话则返回结果。
   3. 否则的话，判断是红黑树节点还是链表结点。如果是红黑树节点的话则到红黑树中查找，如果是链表结点的话则遍历链表查找，并返回相应的结果。
3. 如果最后没有查到，则返回 `null`。

---

`helpTransfer()`

`transfer()`方法为`CHM`扩容的核心方法。在此过程中，`CHM`支持多线程扩容。扩容主要分为两个步骤：

- 构建`nextTable`桶数组，大小为之前的两倍，这个操作在单线程下完成。
- 将`oldTable`里面的内容复制到`nextTable`，这个操作允许多线程操作。可以减少扩容时间。

基本思路与`HashMap`差不多，主要区别在于`CHM`多线程加锁`synchronized (f)`。

---

## 如何保证线程安全，1.7呢？

1. JDK1.8的 CHM 主要采用 `CAS + synchronized` 的方式锁住头结点，细化了锁的粒度。
2. JDK1.7的 CHM 主要采用 `Segment+synchronized` 分段锁实现了线程安全，这个内部类继承了`ReentrantLock`可重入锁这个类。每次加锁都会锁住`Segment`一个段，而一个`Segment`里包含了一个或多个`HashEntry`，锁的粒度较大。

## J.U.C 包下还知道什么类，讲一下？

![J.U.C知识点梳理](https://tva1.sinaimg.cn/large/007S8ZIlly1ghvyl71zbrj31kb0u046x.jpg)

## synchronized 实现原理？和 Lock 的区别？

推荐阅读：

- [synchronized 实现原理](https://xiaomi-info.github.io/2020/03/24/synchronized/)

- [(六) synchronized的源码分析](https://segmentfault.com/a/1190000017255226)

 `synchronized` 基于**对象头**中的 Mark Word实现，其中包括 Mark Word 和 **类型指针**。

`synchronized`是基于`monitor`实现的，而`monitor`则是由`ObjectMonitor`实现的，源码位于`ObjectMonitor.hpp `。

> 暂时先放一放，这部分内容细抠的话太深。

## volatile呢？怎么实现的？

推荐阅读：

- [volatile底层原理详解](https://zhuanlan.zhihu.com/p/133851347)

## 类加载机制与双亲委派模型，自己实现的话怎么做？

**类加载机制**

1. 类加载主要分为三个过程，分别是加载、连接、初始化，其中连接过程又分为验证、准备、解析三个步骤。
2. **加载过程**，在这个过程虚拟机需要完成三件事情
   1. 根据类的全限定名获取定义此类的二进制字节流
   2. 将该二进制字节流所代表的静态存储结构转化为方法区中的运行时数据结构
   3. 在内存中生成一个代表该类的java.lang.Class对象，作为方法区中这个类的各种数据的访问入口。
3. **验证阶段**：目的是确保Class文件的字节流中包含的信息合法，又分为文件格式验证
   1. **文件格式验证**：验证字节流是否符合Class文件格式的规范，比如魔数、主次版本号、常量池等。
   2. **元数据验证**：对字节码描述的信息进行语义分析，对类的元数据信息进行语义校验。是否有父类、是否继承了不该继承的类。
   3. **字节码验证**：通过数据流分析和控制流分析，确定程序语义是否合法，是否符合逻辑。
   4. **符号引用验证**：目的是确保解析行为能够正常进行。
4. **准备阶段**：为类中定义的变量(即静态变量，被`static`修饰的变量)分配内存并设置类变量初始值。
5. **解析阶段**：将常量池内的符号引用替换为直接引用的过程
   1. 类或接口的解析
   2. 字段解析
   3. 方法解析
   4. 接口方法解析
6. **初始化阶段**：此前的阶段都由JVM来主导，初始化阶段开始JVM才真正执行类中编写的Java程序代码，将主导权交给应用程序。
   1. 初始化阶段，会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。
   2. 其实就是执行类构造器`<clinit>()`方法的过程，这个方法是Javac编译器的生成物。

> **符号引用**：符号引用以一组符号来描述所引用的目标，符号可以使任何形式的字面量，只要使用时能无歧义地定位到目标即可。
>
> **直接引用**：直接引用是可以直接指向目标的指针、相对偏移量、或者是一个能间接定位到目标的句柄。

**双亲委派模型**

类加载器有三层，分别是：

- 启动类加载器（Bootstrap Class Loader）：负责加载存放在`<JAVA_HOME>/lib`目录，或者被`-Xbootclasspath`所指定的路径中存放的，而且能够被JVM识别的类库加载到虚拟机的内存中。
- 扩展类加载器（Extension Class Loader）：负责加载`<JAVA_HOME>/lib/ext`目录中，或者被`java.ext.dirs`系统变量所指定的路径中所有的类库。
- 应用程序类加载器（Application Class Loader）：负责加载用户类路径（ClassPath）上所有的类库，如果应用程序中没有自定义过类加载器，这就是默认的类加载器。

双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求(它的搜索范围中没有找到所需的类)时，子加载器才会尝试自己去完成加载。

> 双亲委派模型可以保证一个类只被加载一次，防止核心API被篡改，保证系统的稳定性。

**如何自己实现类加载器？**

1. 继承`java.lang.ClassLoader`类
2. 如果想打破双亲委派模型的话，重写`loadClass()`类
3. 如果不想打破双亲委派模型的话，重写`findClass()`类

## GC讲一下

**判断对象已死**的方法有两个，分别是：

- 引用计数法
- 可达性分析算法

GC选择的是可达性分析算法。

GC基于**分代收集理论**

- 弱分代假说 (Weak Generational Hypothesis): 绝大多数对象都是朝生夕灭的。
- 强分代假说 (Strong Generational Hypothesis): 熬过越多次垃圾收集过程的对象就越难以消亡。
- 跨代引用假说 (Intergenerational Reference Hypothesis): 跨代引用相对于同代引用来说仅占极少数。

三种常用的**垃圾收集算法**

- 标记 - 清除算法
- 标记 - 复制算法
- 标记 - 整理算法

## 说一下你知道的垃圾回收器

推荐阅读：[垃圾收集器与内存分配策略](https://raymond-zhao.top/2020/08/19/2020-08-19-JVM-GC/?cache-bust=1598520100126)

```markdown
经典垃圾收集器
1. Serial
2. ParNew
3. Parallel Scavenge

4. Serial Old
5. CMS：初次标记、并发标记、重新标记、并发清除。 STW阶段(初次标记、重新标记)
6. Parallel Old

7. G1：初次标记、并发标记、再次标记、筛选回收。STW阶段(初次标记、再次标记、筛选回收)

低延迟垃圾收集器
8. Shenandoah 收集器
9. ZGC

JDK11
Epsilon
```

## Class类文件怎么回收？

（不是对象，太菜了，想了半天不知道咋回收，没答上）

```markdown 
方法区的垃圾收集主要回收两部分内容: 废弃的常量和不再使用的类型。
判定一个类型是否属于 “不再被使用的类” ，需要同时满足下面三个条件:

1. 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例。
2. 加载该类的类加载器已经被回收。
3. 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
```

## 浏览器输入url发生了什么？

（细说，包括每一层涉及到的协议）

1. DNS解析（[用到TCP、UDP](https://draveness.me/whys-the-design-dns-udp-tcp/)）
2. TCP三次握手连接（TCP协议）
3. HTTP/HTTPS连接
4. 网关/Nginx 负载均衡
5. 请求到达对应服务，Spring MVC 工作(如果用的Spring)
6. 持久层操作(操作缓存，操作数据库)
7. 返回HTTP响应给客户端
8. 浏览器解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，CDN 加速静态资源，浏览器开始布局渲染树并将其绘制到屏幕上。
9. 四次握手断开连接

## TCP三次握手

![三报文握手建立连接](https://tva1.sinaimg.cn/large/00831rSTly1gd9tsfxtkyj31ce0okdrn.jpg)

1. A 主动打开连接，B 被动打开连接。
2. B的 TCP服务器进程 创建 传输控制块TCB，准备接受客户进程的连接请求，进入监听(Listen)状态。
3. A的 TCP客户端进程 创建 传输控制块TCB。
4. A向B请求建立连接时，发出连接请求报文段，首部中同步位 SYN=1，选择初始序号 seq=x。TCP客户进程进入SYN-SENT(同步已发送)状态。
5. B收到连接请求报文段后，如同意建立连接，则向A发送确认。在确认报文段中携带 SYN=1，ACK=1，ack=x+1，seq=y。服务器进程进入SYN-RCVD(同步收到)状态。
6. TCP客户进程收到B的确认后，向B发出确认。携带 ACK=1，ack=y+1，seq=x+1。TCP连接已经建立，A 进入 ESTABLISHED (已建立连接)状态。
7. 当 B 收到 A 的确认后，也进入 ESTABLISHED 状态。

```
问：为什么 A 最后还要发送一次确认呢?
答：这主要是为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。
如果只有两次握手的话，那么只要 B 发出确认，新的连接就建立了。由于现在 A 并没有发出建立连接的请求，因此不会理睬 B 的确认，也不会向B发送数据。但 B 却以为新的运输连接已经建立了，苦苦地等待 A 发来数据，B 的许多资源就这样白白浪费了。
```

## 四次挥手最后等待为什么 (TIME-WAIT) 2MSL？

![TCP连接的释放过程](https://tva1.sinaimg.cn/large/00831rSTly1gd9uuv1g7cj31ew0r2qje.jpg)

> TIME-WAIT 为什么要等待 2MSL？
>
> - 第一，为了保证 A 发送的最后一个 ACK 报文段能够到达 B。这个 ACK 报文段有可能丢失，因而使处在 LAST-ACK 状态的 B 收不到对已发送的 FIN+ACK 报文段 的确认。B 会超时重传这个 FIN+ACK 报文段，而 A 就能在 2MSL 时间内收到这个重传的 FIN+ACK 报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A 和 B 都正常进入到 CLOSED 状态。**如果 A 在 TIME-WAIT 状态不等待一段时间，而是在发送完 ACK 报文段后立即释放连接，那么就无法收到 B 重传的 FIN+ACK 报文段，因而也不会再发送一次确认报文段。**这样，B就无法按照正常步骤进入 CLOSED 状态。
>
> - 第二，防止“已失效的连接请求报文段”出现在本连接中。A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现这种旧的连接请求报文段。

1. 在关闭连接前，A 和 B 都处于 ESTABLISHED 状态。
2. **A 的应用进程**先向其 TCP 发出连接释放报文段，并停止发送数据，主动关闭 TCP 连接。连接释放报文段首部终止控制位 FIN=1，seq=u，它等于前面已传送过的数据的最后一个字节的序号加 1。A进入 **FIN-WAIT-1(终止等待1)** 状态，等待 B 的确认。
3. B 收到连接释放报文段后即发出确认，确认位 ACK=1，确认号是 ack=u+1，序列号seq=v，等于 B 前面已传送过的数据的最后一个字节的序号加 1。
   1. 进入 **CLOSE-WAIT(关闭等待)** 状态。
   2. TCP 服务器进程通知高层应用进程，此时从 A 到 B 这个方向的连接已释放，TCP连接处于 **半关闭(half-close)** 状态，即 A 已经没有数据要发送了，但 **B 若发送数据，A 仍要接收**。也就是说，从B到A这个方向的连接并未关闭，这个状态可能会持续一段时间。
4. A 收到 B 的确认后，进入 **FIN-WAIT-2(终止等待2)** 状态，等待 B 发出的连接释放报文段。
5. 若 B 已经没有要向A发送的数据，其应用进程就通知 TCP 释放连接。
   1. B 发出的连接释放报文段中终止位 FIN=1，确认位 ACK=1，序列号 seq=w (半关闭状态下 B 可能又发送了一些数据)。
   2. B 还必须**重复上次已发送过的确认号 ack=u+1**。B进入 **LAST-ACK(最后确认)** 状态，等待A的确认。
6. A 收到 B 的连接释放报文段后，对此发出确认。
   1. 在确认报文段中，ACK=1，ack=w+1，seq=u+1，然后进入 **TIME-WAIT(时间等待)** 状态。
   2. 此时 **TCP连接还没有释放掉**，必须经过 **2MSL** 后，A才进入到 **CLOSED状态**。
   3. MSL叫做最长报文段寿命(Maximum Segment Lifetime)，RFC793建议设为2分钟。但 TCP 允许不同实现自定义。因此，从A进入到 **TIME-WAIT状态**后，要经过 **2MSL** 才能进入到 **CLOSED状态**，才能开始建立下一个新的连接。
   4. 当A撤销相应的传输控制块TCB后，就结束了这次的TCP连接。
7. B 收到 A 发出的确认后，才进入 **CLOSED状态**，在 B 撤销 PCB 后，本次 TCP 连接才算结束。

> B 结束 TCP 连接的时间要比 A 早一些，因为 A 要等待 2MSL。

## RIP协议怎么解决的环路问题

```markdown
1. 最大跳数：路由达到16跳就认为不可达。

2. 水平分割：不向原始路由更新来的方向再次发送路由更新信息。

3. 路由毒化：先检测到网络不可达的路由器向周围路由器扩散这个消息。

4. 反向毒化：如果A路由器告诉了B路由器 C路由器不可达，B路由器再反过来告诉A路由器一次。保证所有路由器都收到了毒化的路由信息。

5. 控制更新时间：当路由表中的某个条目所指网络消失时，路由器并不会立刻的删除该条目并学习新条目，而是严格按照我们前面所介绍的计时器时间现将条目设置为无效接着是挂起，在240秒时才删除该条目，这么做其实是为了尽可能的给予一个时间等待发生改变的网络恢复。

6. 触发更新：因网络拓扑发生变化导致路由表发生改变时，路由器立刻产生更新通告直连邻居，不再需要等待30秒的更新周期，这样做是为了尽可能地将网络拓扑的改变通告给其他路由器。
```

## 数据库范式讲一下

```markdown
1. 第一范式：保证每一列都是原子的，不可再分的。
2. 第二范式：在第一范式的基础上，消除了非主属性对码的部分依赖。
3. 第三范式：在第二范式的基础上，消除了非主属性对码的传递依赖。
4. BC范式：在第三范式的基础上，消除对主码子集的依赖。
```

## 数据库引擎讲一下

[MySQL 8.0 - Chapter 16 Alternative Storage Engines](https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html)

| Feature                                    | MyISAM       | Memory           | InnoDB       | Archive      | NDB          |
| ------------------------------------------ | ------------ | ---------------- | ------------ | ------------ | ------------ |
| **B-tree indexes**                         | Yes          | Yes              | Yes          | No           | No           |
| **Clustered indexes**                      | No           | No               | Yes          | No           | No           |
| **Hash indexes**                           | No           | Yes              | No (note 8)  | No           | Yes          |
| **Full-text search indexes**               | Yes          | No               | Yes (note 6) | No           | No           |
| **Index caches**                           | Yes          | N/A              | Yes          | No           | Yes          |
| **Transactions**                           | No           | No               | Yes          | No           | Yes          |
| **MVCC**                                   | No           | No               | Yes          | No           | No           |
| **Locking granularity**                    | Table        | Table            | Row          | Row          | Row          |
| **Foreign key support**                    | No           | No               | Yes          | No           | Yes (note 5) |
| **Data caches**                            | No           | N/A              | Yes          | No           | Yes          |
| **Storage limits**                         | 256TB        | RAM              | 64TB         | None         | 384EB        |
| **Backup/point-in-time recovery** (note 1) | Yes          | Yes              | Yes          | Yes          | Yes          |
| **Cluster database support**               | No           | No               | No           | No           | Yes          |
| **Compressed data**                        | Yes (note 2) | No               | Yes          | Yes          | No           |
| **Encrypted data**                         | Yes (note 3) | Yes (note 3)     | Yes (note 4) | Yes (note 3) | Yes (note 3) |
| **Geospatial data type support**           | Yes          | No               | Yes          | Yes          | Yes          |
| **Geospatial indexing support**            | Yes          | No               | Yes (note 7) | No           | No           |
| **Replication support** (note 1)           | Yes          | Limited (note 9) | Yes          | Yes          | Yes          |
| **T-tree indexes**                         | No           | No               | No           | No           | Yes          |
| **Update statistics for data dictionary**  | Yes          | Yes              | Yes          | Yes          | Yes          |

**Notes:**

1. Implemented in the server, rather than in the storage engine.

2. Compressed MyISAM tables are supported only when using the compressed row format. Tables using the compressed row format with MyISAM are read only.

3. Implemented in the server via encryption functions.

4. Implemented in the server via encryption functions; In MySQL 5.7 and later, data-at-rest tablespace encryption is supported.

5. Support for foreign keys is available in MySQL Cluster NDB 7.3 and later.

6. InnoDB support for FULLTEXT indexes is available in MySQL 5.6 and later.

7. InnoDB support for geospatial indexing is available in MySQL 5.7 and later.

8. InnoDB utilizes hash indexes internally for its Adaptive Hash Index feature.

## 隔离级别

1. READ UNCOMMITTED(未提交读)
2. READ COMMITTED(已提交读)
3. REPEATABLE READ(可重复读)
4. SERIALIZABLE(串行化)

## 有哪些索引，为什么用 B+ 树？

- 哈希虽然能够提供 `O(1)` 的单数据行操作性能，但是对于范围查询和排序却无法很好地支持，最终导致全表扫描；
- B 树能够在非叶节点中存储数据，这导致在**查询连续数据时**可能会带来更多的随机 I/O，而 B+ 树的所有叶节点可以通过指针相互连接，能够减少顺序遍历时产生的额外随机 I/O。
- IO 次数取决于 B+ 树的高度，所以树越低，IO次数越少。当数据量一定时，树的高度取决于 B+ 树的阶 m，而 m = (磁盘块大小/数据项大小) = (页大小/数据项大小)，所以如果中间结点只存储索引的话，将可以存储更多的数据项。

推荐阅读：

- [面试官，你要是敢在问我B+树，别怪我不客气！！](https://mp.weixin.qq.com/s/DtbWSGnjt001JMR78tjt5A)

- [为什么 MySQL 使用 B+ 树](https://draveness.me/whys-the-design-mysql-b-plus-tree/)

```markdown
1. 按数据结构分：BTree索引、Hash索引
2. 按数据的组织方式分：聚簇索引、非聚簇索
3. 按包含的列数量分：单列索引、组合索引
4. 按是否主键分：主键索引、辅助索引
5. 另外还有唯一索引、全文索引

为什么用B+树 ？
这需要联系到我们平常使用的SQL语句，我们使用的比较多的SQL主要包括下面三类：
1. 根据某个值进行精确查找
2. 根据区间进行查找
3. 进行顺序查找或逆序查找

我们常用的数据结构有数组、链表、散列表、树等
1. 数组支持快速查找，但是需要占用大量的连续存储空间、如果为了保持有序，增删元素需要移动数据比较麻烦；
2. 链表不用占用连续存储空间，但不支持快速查找，在非首尾结点增删元素也比较麻烦；
3. 散列表可以非常快速地进行精确查找，但是只支持等值匹配，不支持区间查找和顺序查找；
4. 在双向链表之上加多层索引可以改造出跳表，跳表也可以实现快速查找，区间查询，顺序查询，实际上，跳表已经与 B+树 非常相似了，不同的是，跳表是从链表演化而来，而 B+树 是从平衡二叉搜索树演化而来；
5. 关于 B树 与 B+树
  5.1 B树遍历元素时效率低下
  B+ 树只需要去遍历叶子节点就可以实现整棵树的遍历，而在 B树 中遍历数据则需要进行中序遍历。而且在数据库中基于范围的查询是非常频繁的，而 B树 不支持这样的操作或者说效率太低。
  5.2 B+树中间节点只存索引，不存数据，所以体积更小，在磁盘大小一定时，相比B树，磁盘可以存储更多B+树中间节点，减少了IO次数。
  5.3 B+树的查找更稳定，数据都存储在叶子节点上，查找数据总是要走到叶子节点，而B树查找到数据后就返回。
```

## 项目哪里用到了 Redis，说一下常用数据类型的使用场景

```markdown
1. 缓存商城首页三级分类菜单
2. 解决分布式环境下的 Session 共享同步
3. 读写数据时，使用 Redis 实现分布式读写锁

1. String：常规 key-value 缓存应用；常规计数：微博数，粉丝数等
2. Hash：存储对象；存储用户信息，商品信息
3. List：关注列表，粉丝列表；消息队列
4. Set：去重；交集、并集；共同关注列表
5. ZSet：在 Set 的基础上进行排序；打赏粉丝列表
```

## 四大大问题解决

```markdown
1. 缓存雪崩：
  给缓存数据设置过期时间时加上一个随机值。
2. 缓存穿透：
  1.1 布隆过滤器提前拦截请求；
  1.2 把不存在的对象也放到缓存，设置一个较短的过期时间。
3. 缓存击穿：
  使用互斥锁，在第一个查询请求到来时获得锁，其他线程到来时将会阻塞，等第一个查询查询后将结果放到缓存，后面的线程可以直接走缓存。
4. 双写一致性：
  1.1 利用消息队列实现最终一致性，利用消息队列的重试机制来保证能够更新成功；
  1.2 写数据的时候加上分布式读写锁。
```

## 刚刚提到的分布式锁怎么实现的

推荐阅读：[再有人问你分布式锁，这篇文章扔给他](https://juejin.im/post/6844903688088059912)

```markdown
采用了两种实现方式
1. 使用 Redis+Lua 脚本
  1.0 setIfAbsent("lock", uuid, 300, TimeUnit.SECONDS)
  1.1 使用 set ex nx 命令进行原子加锁
  1.2 使用 redis + lua 脚本进行原子解锁
2. 使用 Redisson
```

## Unicode和UTF-8和ASCLL之间的关系

推荐阅读：[阮一峰 - 字符编码笔记：ASCII，Unicode 和 UTF-8](http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html)

```markdown
1. ASCII码，起初只为英语服务，1个字节8bit，第一位为0，后面七位可以表示英语中的128个字符；扩展的ASCII码为256个，使用了最高位，可以用于欧美语系。
2. 扩展的ASCII码能表示的范围也很有限，但是如汉语有超过10W个不同字符，所以需要更大的表示字符的编码方式。Unicode是一个巨大的符号集，每个符号的编码不一样，但是Unicode并没有定义字符的二进制编码应该如何存储。
3. UTF-8 是 Unicode 的一种实现方式，使用变长编码，使用1~4字节表示一个符号，根据不同符号而变化字节长度。
```

## Spring里面的设计模式

推荐阅读：[面试官:“谈谈Spring中都用到了那些设计模式?”](https://juejin.im/post/6844903849849962509)

```markdown
1. 工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。
2. 代理设计模式 : Spring AOP 功能的实现。
3. 单例设计模式 : Spring 中的 Bean 默认都是单例的。
4. 模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。
5. 包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。
6. 观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。
7. 适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。
```

## 还知道哪些设计模式？

```markdown
1. 原型模式
2. 抽象工厂模式
3. 建造者模式
4. 组合模式
5. 享元模式
```

## 写个单例吧

```java
// 懒汉式
public class Singleton {
    // volatile 禁止指令重排
    private static volatile Singleton instance;

    private Singleton() {}

    public static getInstance() {
        // 1. 避免在 instance 已经实例化的情况下进入同步代码块
        if (instance == null) {
            synchronized(Singleton.class) {
                // 2. 避免在线程A进入同步代码块时
                // 单例已被线程B实例化
                if (instance == null)
                    // 3. 这一步其实在字节码层面包含三步
                    // 3.1 为 instance 获取内存地址
                    // 3.2 初始化 instance 对象
                    // 3.3 将内存地址指向 instance 对象
                    instance = new Singleton();
            }
        }
        return instance;
    }
}
```

## 时间差不多了，写个简单的题目吧（单词翻转）

```java
// LeetCode 剑指Offer 58-I
public String reverseWords(String s) {
    s = s.trim();
    int j = s.length() - 1, i = j;
    StringBuilder res = new StringBuilder();
    while (i >= 0) {
        while (i >= 0 && s.charAt(i) != ' ') i--;
        res.append(s.substring(i + 1, j + 1) + " ");
        while (i >= 0 && s.charAt(i) == ' ') i--;
        j = i;
    }
    return res.toString().trim();
}
```



