# 作者：牛客985552842号

链接：https://www.nowcoder.com/discuss/447663?channel=666&source_id=home_feed
来源：牛客网

## 1、 自我介绍（会根据自我介绍，问一点问题）

## 2、 编程题：求二叉树的深度

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
```

### Solution-递归(DFS)

```java
public int maxDepth(TreeNode root) {
    // 返回左右子树中深度较大的那一个，然后再加上 1
    if (root == null) return 0;
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
```

### Solution-层次遍历(BFS)

```java
public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    List<TreeNode> queue = new LinkedList<>();
    List<TreeNode> tmp;
    queue.add(root);
    int res = 0;
    while (!queue.isEmpty()) {
        tmp = new LinkedList<>();
        // 分别加入左右子树的结点
        for (TreeNode treeNode : queue) {
            if (treeNode.left != null) tmp.add(treeNode.left);
            if (treeNode.right != null) tmp.add(treeNode.right);
        }
        res++;
        queue = tmp;
    }
    return res;
}
```

## 3、 编程题：求一个数组中的众数

> 如果输入的数组为空，你会输出什么  

### Solution-哈希

> 只要跟数数有关的题，总可以用哈希来解决。

### Solution-快排

```java
/**
* JDK 快排
*/
public int majorityElement(int[] nums) {
    if (nums == null || nums.length == 0) return Integer.MAX_VALUE;
    Arrays.sort(nums);
    return nums[nums.length / 2];
}
```

```java
/**
* 手动 快排 超出时间限制
*/
class Solution {
    public int majorityElement(int[] nums) {
        quickSort(nums, 0, nums.length - 1);
        return nums[nums.length / 2];
    }

    public int[] quickSort(int[] array, int p, int r) {
        if (p < r) {
            int q = partition(array, p, r);
            quickSort(array, p, q - 1);
            quickSort(array, q + 1, r);
        }
        return array;
    }

    private int partition(int[] array, int p, int r) {
        int x = array[r];
        int i = p - 1;
        for (int j = p; j < r; j++) {
            if (array[j] <= x) {
                i++;
                swap(array, i, j);
            }
        }
        swap(array, i + 1, r);
        return i + 1;
    }

    private void swap(int[] a, int i, int j) {
        int temp = a[i];
        a[i] = a[j];
        a[j] = temp;
    }
}
```

### Solution-摩尔投票

```java
public int majorityElement(int[] nums) {
    int votes = 0, x = 0;
    for (int num : nums) {
        if (votes == 0)
            x = num;
        votes += num == x ? 1 : -1;
    }
    return x;
}
```

> 扩展：众数II(出现次数 $\lfloor n/3 \rfloor$ 的数字)

## [4、 输入网址后，会经历哪几个步骤？](https://juejin.im/post/5b148a2ce51d4506965908d2)

```markdown
输入 URL -> 缓存(浏览器缓存 -> 系统缓存 -> 路由器缓存) -> DNS 解析(本地 DNS -> ISP缓存 -> 根域名服务器 -> 顶级域名服务器 -> 二级域名服务器) -> TCP 连接(三次握手) -> HTTP连请求 -> 服务器处理请求(负载均衡系统，数据库/缓存操作) —> HTTP Response  -> 页面渲染(浏览器收到响应后，构建dom树 -> 构建render树 -> 布局render树 -> 绘制render树) -> 关闭连接(四次分手)
```

## 5、 其中`DNS`解析具体是解析什么

```markdown
将便于人记忆的网址解析为服务器的IP地址
```

## 6、 如果每个`DNS`对应一个`ip`，那么这个是怎么存储的，存在哪里

```markdown
看不明白问题具体是想干什么
```

## 7、 `Java`中引用分为几种，分别解释一下。

- 强引用 (`Strong Reference`)
  - 最普遍的引用：`Object obj = new Object();`
  - 抛出 `OutOfMemoryError` 终止程序也不会回收具有强引用的对象
  - 通过将对象设置为 `null` 来软化引用，使其被回收
- 软引用 (`Soft Reference`)
  - 对象处在有用但非必须的状态
  - 只有当内存空间不足时，GC 才会回收该引用的对象的内存
  - 可以用来实现**高速缓存**
- 弱引用 (`Weak Reference`)
  - 非必须的对象，比软引用更弱一些
  - GC 时会被回收
  - 被回收的概率也不大，因为 GC 线程优先级比较低
  - 适用于引用偶尔被使用且不影响垃圾收集的对象
- 虚引用 (`Phantom Reference`)
  - 不会决定对象的生命周期
  - 任何时候都可能被 GC 回收
  - 跟踪对象被垃圾收集器回收的活动，起哨兵的作用
  - 必须和引用队列 `ReferenceQueue` 联合使用

| 引用类型 | 被垃圾回收时间 | 用途           | 生存时间           |
| :------- | :------------- | :------------- | :----------------- |
| 强引用   | 从来不会       | 对象的一般状态 | JVM 停止运行时终止 |
| 软引用   | 内存不足时     | 对象缓存       | 内存不足时终止     |
| 弱引用   | 垃圾回收时     | 对象缓存       | GC 运行后终止      |
| 虚引用   | 不确定         | 标记、哨兵     | 不确定             |

## 8、 `HashMap`底层原理，当`hashcode`发生碰撞之后，怎么解决这个问题

[Java 8系列之重新认识HashMap - 美团](https://zhuanlan.zhihu.com/p/21673805)

[一文搞懂面试中的Map-掘金](https://juejin.im/post/5d09f2d56fb9a07ec7551fb0)

## 9、 `HashMap`的负载因子可以改变吗，可以改为 $1$ 吗？

```markdown
可以改变吗？当然可以！
可以改为 1 吗？改为大于 1 都可以。
```

[HashMap负载因子超过1会怎样 - 掘金](https://juejin.im/post/5dcb53a8e51d45225371ad30)

## 10、`HashMap`的构造函数有多少种

- 四种

```java
/**
* Constructs an empty <tt>HashMap</tt> with the specified initial
* capacity and load factor.
*
* @param  initialCapacity the initial capacity
* @param  loadFactor      the load factor
* @throws IllegalArgumentException if the initial capacity is negative
*         or the load factor is nonpositive
*/
public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal initial capacity: " +
                                           initialCapacity);
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor <= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException("Illegal load factor: " +
                                           loadFactor);
    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(initialCapacity);
}

/**
* Constructs an empty <tt>HashMap</tt> with the specified initial
* capacity and the default load factor (0.75).
*
* @param  initialCapacity the initial capacity.
* @throws IllegalArgumentException if the initial capacity is negative.
*/
public HashMap(int initialCapacity) {
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}

/**
* Constructs an empty <tt>HashMap</tt> with the default initial capacity
* (16) and the default load factor (0.75).
*/
public HashMap() {
    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted
}

/**
* Constructs a new <tt>HashMap</tt> with the same mappings as the
* specified <tt>Map</tt>.  The <tt>HashMap</tt> is created with
* default load factor (0.75) and an initial capacity sufficient to
* hold the mappings in the specified <tt>Map</tt>.
*
* @param   m the map whose mappings are to be placed in this map
* @throws  NullPointerException if the specified map is null
*/
public HashMap(Map<? extends K, ? extends V> m) {
    this.loadFactor = DEFAULT_LOAD_FACTOR;
    putMapEntries(m, false);
}
```

> 扩展：线程池有多少种构造函数？
>
> 答案：4 种

```java
/**
* 1
*/
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), defaultHandler);
}

/**
* 2
*/
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         threadFactory, defaultHandler);
}

/**
* 3
*/
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          RejectedExecutionHandler handler) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         Executors.defaultThreadFactory(), handler);
}

/**
* 4
*/
public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue<Runnable> workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    if (corePoolSize < 0 ||
        maximumPoolSize <= 0 ||
        maximumPoolSize < corePoolSize ||
        keepAliveTime < 0)
        throw new IllegalArgumentException();
    if (workQueue == null || threadFactory == null || handler == null)
        throw new NullPointerException();
    this.acc = System.getSecurityManager() == null ?
        null :
    AccessController.getContext();
    this.corePoolSize = corePoolSize;
    this.maximumPoolSize = maximumPoolSize;
    this.workQueue = workQueue;
    this.keepAliveTime = unit.toNanos(keepAliveTime);
    this.threadFactory = threadFactory;
    this.handler = handler;
}
```

## 11、`HashMap`线程安全的吗？多线程使用会发生哪些问题，具体解释一下怎么发生问题，有哪些安全的`Map`   

```markdown
不是。
resize() 可能会出现 infinite loop
```

```markdown
由于HashMap的容量是有限的，如果HashMap中的数组的容量很小，假如只有2个，那么如果要放进10个keys的话，碰撞就会非常频繁，此时一个O(1)的查找算法，就变成了链表遍历，性能变成了O(n)，这是Hash表的缺陷。

为了解决这个问题,HashMap设计了一个阈值，其值为容量的0.75，当HashMap所用容量超过了阈值后，就会自动扩充其容量。

在多线程的情况下，当重新调整HashMap大小的时候，就会存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历。如果条件竞争发生了，那么就会产生死循环了。
```

```markdown
ConcurrentHashMap

HashTable

ConcurrentSkipListMap

WeakKeyConcurrentHashMap
```

## 12、线程和进程的区别

```markdown
进程是一个独立的运行环境，而线程是在进程中执行的一个任务。他们两个本质的区别是是否单独占有内存地址空间及其它系统资源（比如I/O）：
进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，数据共享复杂但是同步简单，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂。
进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，可靠性高；一个线程崩溃可能影响整个程序的稳定性，可靠性较低。
进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，开销较大；线程只需要保存寄存器和栈信息，开销较小。
另外一个重要区别是，进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位，即CPU分配时间的单位 。
```

## 13、进程中必须有线程吗

```markdown
是的，一个程序至少有一个进程，一个进程至少有一个线程。
```

## 14、为什么说`TCP`协议是安全的

https://hit-alibaba.github.io/interview/basic/network/TCP.html

## 15、怎么确认客户端和服务器端进行传输数据时，数据有没有丢失，如果发现数据块丢失会怎么办，会发送什么请求，跟三次握手四次挥手有关系吗？

## 16、其他的流量控制有了解吗？

小哥哥的建议：  

注意代码中的细节，尽量能够自己在脑海中模拟代码的运行找出错误

编写程序的时候注意异常情况的处理

 Java基础不是很好，需要继续学习

计算机网络掌握的也不太好

操作系统还可以，但是也需要学习  

