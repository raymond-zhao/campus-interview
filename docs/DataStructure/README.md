## 数据结构

- [数组与链表]()
- [栈与队列]()
- [二叉树]()
- [B- Tree]()
- [红黑树]()
- [图]()

## 排序算法

- [十大排序算法比较与总结](https://raymond-zhao.top/2020/03/19/2020-03-19-Algo-Sorting/)



| 分类 |   算法名称   |     平均      |     最好     |    最坏     | 空间复杂度 | 稳定性 |
| :--: | :----------: | :-----------: | :----------: | :---------: | :--------: | :----: |
| 插入 |   直接插入   |   $O(n^2)$    |    $O(n)$    |  $O(n^2)$   |   $O(1)$   |  $Y$   |
| 插入 |   折半插入   |   $O(n^2)$    | $O(n\lg n)$  |  $O(n^2)$   |   $O(1)$   |  $Y$   |
| 插入 |   希尔排序   |  $O(n\lg n)$  | $O(n^{1.3})$ |  $O(n^2)$   |   $O(1)$   |  $N$   |
| 交换 |   冒泡排序   |   $O(n^2)$    |    $O(n)$    |  $O(n^2)$   |   $O(1)$   |  $Y$   |
| 交换 |   快速排序   |  $O(n\lg n)$  | $O(n\lg n)$  |  $O(n^2)$   | $O(\lg n)$ |  $N$   |
| 选择 | 简单选择排序 |   $O(n^2)$    |   $O(n^2)$   |  $O(n^2)$   |   $O(1)$   |  $N$   |
| 选择 |    堆排序    |  $O(n\lg n)$  |    $O(n)$    | $O(n\lg n)$ |   $O(1)$   |  $N$   |
| 归并 |   二路归并   |  $O(n\lg n)$  | $O(n\lg n)$  | $O(n\lg n)$ |   $O(n)$   |  $Y$   |
| 线性 |   基数排序   |  $O(d(n+r))$  | $O(d(n+r))$  | $O(d(n+r))$ |  $O(r+n)$  |  $Y$   |
| 线性 |   计数排序   | $\Theta(n+k)$ |   $O(n+k)$   |  $O(n+k)$   |   $O(k)$   |  $Y$   |
| 线性 |    桶排序    |   $O(n+k)$    |    $O(n)$    |  $O(n^2)$   |  $O(n*k)$  |  $Y$   |

- 平均而言，**快速排序**最佳，最坏情况下不如**堆排序**与**归并排序**。
- 直接插入排序，折半插入排序，简单选择排序，冒泡排序等时间复杂度为 $O(n^2)$ 的排序不适用与 $n$ 较大的情况。
- 一趟排序至少能保证一个关键字到达最终位置的排序：交换类(冒泡排序，快速排序)，选择类排序(简单选择排序，堆排序)。
- 关键字比较次数和原始序列无关的排序：简单选择排序，折半插入排序，归并排序，基数排序。
- 排序趟数和原始序列有关的排序：交换类排序(冒泡排序，快速排序)。
- 排序趟数与原始序列无关的排序：直接插入排序，折半插入排序，希尔排序，堆排序，二路归并排序，简单选择排序，基数排序。
- 借助于**比较**进行排序的算法，最坏时间复杂度至少为 $O(n\lg n)$ 。
- 直接插入和折半插入的区别仅在于查找插入位置的方式不同。
- 元素的移动次数与原始序列无关的排序：基数排序。
- 不稳定排序：快速排序，希尔排序，简单选择排序，堆排序。
- 时间复杂度为 $O(n\lg n)$ 的排序：快速排序，希尔排序，二路归并排序，堆排序。
- 计数排序不是比较排序，因此不受 $\Omega(n\lg n)$ 的限制。