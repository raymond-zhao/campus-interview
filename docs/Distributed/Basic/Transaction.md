## 分布式与集群

- 分布式是指将不同的业务分布在不同的地方；而集群指的是将几台服务器集中在一起，实现同一业务。
- 分布式中的每一个节点，都可以利用集群来实现，而集群并不一定就是分布式的。 
- 分布式的每一个节点，都完成不同的业务，一个节点垮了，那这个业务将不可访问。
- 分布式是指通过网络连接的多个组件，通过交换信息协作而形成的系统。而集群是指同一种组件的多个实例，形成的逻辑上的整体。
- 集群是个物理形态，分布式是个工作方式。

## 事务解决方案

- 二阶提交（XA）协议
- TCC 方案
- SAGA 方案
- 本地消息表
- 可靠消息最终一致性方案
- 最大努力通知方案

### 二阶提交协议

二阶提交协议（Two Phase Commitment Protocol）：包括 **Prepare**，**Commit** 两个阶段。几个核心点：

- **事务管理器：**负责协调多个数据库（资源管理器）的事务。
- 第一阶段：预留事务所需的资源，**询问**各个数据库是否已准备好提交事务；
- 第二阶段：如果各个数据库均回复可以提交，则**执行**事务提交操作。
- 应用场景：单体应用，跨多个库的分布式事务，因为严重依赖数据库层面来完成复杂的事务，所以效率低，不适合高并发场景。

![XA](https://gitee.com/raymond-zhao/oss/raw/master/uPic/image-20201008101748937.png)

### TCC 方案

TCC：Try、Confirm、Cancel

- Try：对各个服务的资源做检测以及对资源进行**锁定或者预留**。
- Confirm：在各个服务中**执行实际的操作**。
- Cancel：如果任何一个服务的业务方法执行出错，那么这里就需要**进行补偿**，就是执行已经执行成功的业务逻辑的回滚操作。

> 缺陷：**严重依赖于开发人员自实现代码进行回滚与反向补偿**，造成补偿代码巨大。一般只用于跟 Money 相关的场景，比如 下订单、转账等。以追求强一致性和更高的并发量。

![TCC](https://gitee.com/raymond-zhao/oss/raw/master/uPic/image-20201008101711825.png)

### Saga 方案

> - [Saga 概念](https://redux-saga-in-chinese.js.org/docs/introduction/SagaBackground.html)
>
> - [最初论文 - 1987](http://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf)

**补偿协议：**业务流程中每个参与者都提交本地事务，当出现某一个参与者失败则补偿前面已经成功的参与者。

Saga 是一种补偿协议，在 Saga 模式下，分布式事务内有多个参与者，每一个参与者都是一个**冲正补偿**服务，需要用户根据业务场景实现其**正向操作和逆向回滚操作**。

![distributed-transacion-TCC](https://doocs.github.io/advanced-java/docs/distributed-system/images/distributed-transaction-saga.png)

- 在分布式事务执行过程中，依次执行各参与者的**正向操作**；
- 如果所有**正向操作**均执行**成功**，那么分布式事务提交；
- 如果任何一个**正向操作**执行**失败**，那么分布式事务会退回去执行前面各参与者的**逆向回滚**操作，回滚已提交的参与者，使分布式事务回到初始状态。

**适用场景：**

- 业务流程长，业务流程多（长事务）；
- 参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口。

**优势：**

- 一阶段提交本地事务，无锁，高性能；
- 参与者可异步执行，高吞吐；
- 补偿服务易于实现，因为一个更新操作的反向操作是比较容易理解的。

**缺点：**

- 不保证事务的隔离性。

### 本地消息表

**流程梗概：**

- A 系统在本地事务操作的同时，插入一条数据到**消息表（数据库表）**；
- A 系统把这条消息发送到 MQ 中去；
- B 系统收到消息之后，往自己本地**消息表**插入一条数据，同时执行其他业务操作，如果**本条消息**已被处理过，那么 B 所在的事务将会回滚，这样可以**保证不会重复处理消息**；
- B 系统执行成功之后，更新**本地消息表**及 **A 系统消息表**状态；
- 如果 B 系统处理失败，将不会更新消息表状态，此时 A 系统会定时扫描自己的消息表，如果有未处理的消息，会再次发送到 MQ 中，让 B 再次进行处理；
- 此方案保证了最终一致性，即使 B 事务失败了，A 也会不断重发消息，直到 B 也成功为止。

> 缺陷：严重依赖于**数据库消息表**来进行事务管理，不适用于高并发场景，且扩展性较低。

### 可靠消息最终一致性方案

**流程梗概：**

- A 系统先发送一条 prepared 消息到 MQ，
  - 如果这条 prepared 消息发送失败，则直接取消操作；
  - 如果这条 prepared 消息发送成功，则继续执行本地事务，如果事务执行成功就告诉 MQ 发送确认消息，如果失败则告诉 MQ 回滚消息；
- 如果 A 成功发送了确认消息，此时 B 系统会接收到确认消息，然后执行本地事务；
- MQ 会**定时轮询**所有 prepared 消息进行接口回调，检查本地事务是否执行失败，所以未发送确认消息，决定此时是**重试**还是**回滚**。此时可以检查数据库看看本地事务是否成功执行，如果失败回滚，那么这里也失败回滚。这种方式可以**避免本地事务执行成功，而确认消息却发送失败**。
- 如果 B 系统事务失败，将会进行重试，直到成功为止，如果实在不能成功，要么针对重要的资金类业务进行回滚，比如 B 系统本地回滚后，设法使 A 系统也进行回滚，或者发送警报由人工手动回滚和补偿。

### 最大努力通知方案

**流程梗概：**

- A 系统执行完本地事务之后，发送消息到 MQ；
- 这里会有个专门消费 MQ 的**最大努力通知服务**，这个服务会消费 MQ 然后写入数据库中记录下来，或者是放入内存队列，接下来调用 B 系统的接口；
- 如果 B 系统执行成功，那可喜可贺，但是如果 B 系统执行失败，那么最大努力通知服务将会定时尝试重新调用系统 B，，如此反复 N 次未果的话将会放弃。

## 如何选型分布式事务？

- 对于要求强一致性的场景，使用 TCC 方案，比如涉及到资金的场景；
- 一般的分布式场景，使用最终一致性方案。

## Seata 中的事务控制

> 详情见 [SpringCloud 部分的 Seata 工作原理](Spring/SpringCloud)

**四种事务模式：**

- [AT 模式](http://seata.io/zh-cn/docs/dev/mode/at-mode.html)
- [TCC 模式](http://seata.io/zh-cn/docs/dev/mode/tcc-mode.html)
- [Saga 模式](http://seata.io/zh-cn/docs/user/saga.html)
- [XA 模式](http://seata.io/zh-cn/docs/dev/mode/xa-mode.html)

## 参考资料

- [分布式事务 Seata Saga 模式首秀以及三种模式详解](https://www.sofastack.tech/blog/sofa-meetup-3-seata-retrospect/)
- [Seata.io 文档](http://seata.io/zh-cn/docs/overview/what-is-seata.html)
- [分布式事务 - Doocs](https://doocs.github.io/advanced-java/#/./docs/distributed-system/distributed-transaction)

