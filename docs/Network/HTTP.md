## 浏览器输入 url 发生了什么？

（细说，包括每一层涉及到的协议）

1. 浏览器查询缓存（强缓存、协商缓存）
2. [DNS 解析](Network/HTTP?id=dns-解析)、涉及**负载均衡**
3. [TCP 三次握手连接（TCP协议）](Network/TCPIP?id=三次握手)
4. [HTTP/HTTPS 连接](Network/HTTP?id=https-工作流程)
5. 网关/Nginx 负载均衡
6. 请求到达对应服务，[Spring MVC 工作](Spring/Spring?id=spring-mvc-工作流程)
7. 持久层操作(操作缓存，操作数据库)
8. 返回 [HTTP 响应](Network/HTTP?id=http-状态码)给客户端
9. 浏览器解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，CDN 加速静态资源，浏览器开始布局渲染树并将其绘制到屏幕上。
10. [四次握手断开连接](Network/TCPIP?id=四次挥手)

## DNS 解析

[刚开始使用的是 UDP，现在逐渐新增 TCP。](https://draveness.me/whys-the-design-dns-udp-tcp/)

- 第一，**主机** 向 **本地域名服务器** 的查询一般都是采用**递归查询**。
- 第二，**本地域名服务器** 向 **根域名服务器** 的查询通常是采用**迭代查询**。

![DNS 解析](https://tva1.sinaimg.cn/large/007S8ZIlly1gj8etiageoj30ng0h7dpd.jpg)

## DNS 劫持

[Domain name server (DNS) Hijacking](https://www.imperva.com/learn/application-security/dns-hijacking-redirection/)

![Example of DNS Hijacking and Redirection](https://tva1.sinaimg.cn/large/007S8ZIlly1gj8lwtjikyj30fw0bpweo.jpg)

## POP3 与 SMTP 的区别

## HTTP 与 HTTPS 基础

- HTTP：超文本传输协议（HyperText Transfer Protocol）。
- HTTPS：超文本传输安全协议（HyperText Transfer Protocol）。

> HTTP的缺点：
>
> - 使用明文通信（不加密），内容可能会被窃听；
> - 不验证通信方的身份，有可能遭遇伪装；
> - 无法验证报文的完整性，有可能被篡改。

## HTTP 与 HTTPS 的区别

| 方面     | HTTP                                                | HTTPS                                                   |
| :------- | :-------------------------------------------------- | :------------------------------------------------------ |
| 开发目的 | 发布和接收 HTML 页面 浏览器和网站服务器之间传递信息 | 提供对网站服务器的身份认证 保护交换数据的隐私与完整性。 |
| 连接端口 | 80                                                  | 443                                                     |
| 安全协议 | 无                                                  | SSL/TLS                                                 |
| 加密方式 | 无                                                  | 对称加密、非对称加密、哈希算法、数字签名                |
| 安全性   | 明文传输、相对较低                                  | 加密传输、相对较高                                      |
| 建立连接 | TCP 三次握手交换 3 个包                             | TCP3 个包 + SSL9 个包                                   |
| 响应速度 | 相对较快                                            | 相对较慢 (比 HTTP 慢 2 到 100 倍)                       |
| 所需费用 | 免费                                                | 可能需要购买证书                                        |

## SSL 与 TLS

- [SSL(Secure Sockets Layer安全套接层)](https://baike.baidu.com/item/安全套接层)
- [TLS (**T**ransport **L**ayer **S**ecurity 传输层安全性协议)](https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A)

TLS 与  SSL 的差异

- 版本号：TLS 记录格式与 SSL 记录格式相同，但版本号的值不同，TLS1.0 使用的版本号为 SSLv3.1。
- 报文鉴别码：SSLv3.0 和 TLS 的 MAC 算法及 MAC 计算的范围不同。TLS 使用 HMAC 算法。SSLv3.0 使用了相似的算法，两者差别在于 SSLv3.0 中，填充字节与密钥之间采用的是**连接运算**，而 HMAC 算法采用的是**异或运算**。

- 伪随机函数：TLS 使用了称为 PRF 的伪随机函数来将密钥扩展成数据块。

- 报警代码：TLS 在支持几乎所有的SSLv3.0报警代码的基础上，补充定义了很多报警代码，如解密失败（decryption_failed）、记录溢出（record_overflow）、未知CA（unknown_ca）、拒绝访问（access_denied）等。

- 密文族和客户证书：SSLv3.0 和 TLS 存在少量差别，TLS 不支持 Fortezza 密钥交换、加密算法和客户证书。

- certificate_verify 和 finished 消息：SSLv3.0 和 TLS 在用 certificate_verify 和 finished 消息计算 MD5 和 SHA-1 散列码时，计算的输入有少许差别，但安全性相当。

- 加密计算：TLS 与 SSLv3.0 在计算**主密值(master secret)**时采用的方式不同。

- 填充：用户数据加密之前需要增加的填充字节。
  - 在 SSL 中，填充后的数据长度要达到密文块长度的最小整数倍。
  - 在 TLS 中，填充后的数据长度可以是密文块长度的任意整数倍（但填充的最大长度为255字节），这种方式可以防止基于对报文长度进行分析的攻击。

## HTTP 请求方法

|  方法名   |                             作用                             |
| :-------: | :----------------------------------------------------------: |
|   `GET`   |                 向指定的资源发出“显示”请求。                 |
|  `PATCH`  |                  用于将局部修改应用到资源。                  |
|  `POST`   |           向指定资源提交数据，请求服务器进行处理。           |
|   `PUT`   |                向指定资源位置上传其最新内容。                |
| `DELETE`  |          请求服务器删除 Request-URI 所标识的资源。           |
|  `HEAD`   | 与 GET 方法一样，都是向服务器发出指定资源的请求。只不过服务器将不传回资源的本文部分。 |
|  `TRACE`  |          回显服务器收到的请求，主要用于测试或诊断。          |
| `OPTIONS` |        可使服务器传回该资源所支持的所有HTTP请求方法。        |
| `CONNECT` |                 通常用于SSL加密服务器的链接                  |

## GET 与 POST 区别

|         比较方面          |                             GET                              |                             POST                             |
| :-----------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 请求主体（Request Body）  |                     只有URL，无请求主体                      |                          有请求主体                          |
| 响应主体（Response Body） |                              有                              |                              有                              |
|       后退按钮/刷新       |                           无副作用                           |                       数据会被重新提交                       |
|           书签            |                         可收藏为书签                         |                        不可收藏为书签                        |
|           缓存            |                           可被缓存                           |                           不能缓存                           |
|         编码类型          |             `application/x-www-form-urlencoded`              | `application/x-www-form-urlencoded`<br />`multipart/form-data`<br />`text/plain` |
|           历史            |                    参数保留在浏览器历史中                    |                  参数不会保存在浏览器历史中                  |
|          URL长度          | 有限制，但不同浏览器限制又不同。常说的2KB其实是指IE8，Chrome和Apache为8KB |    无限制(Post请求本身不限制长度，但是服务器是会限制的。)    |
|     对数据类型的限制      |                      只允许 ASCII 字符                       |       没有限制、也允许二进制数据，Percent Encoding编码       |
|          安全性           | 与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET | POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。 |
|          幂等性           |                             支持                             |                            不支持                            |
|          可见性           |               数据在 URL 中对所有人都是可见的                |                    数据不会显示在 URL 中                     |

> POST 与 PUT 区别

## HTTP 状态码

- [1xx消息](https://zh.wikipedia.org/wiki/HTTP状态码#1xx消息)——请求已被服务器接收，继续处理。

- [2xx成功](https://zh.wikipedia.org/wiki/HTTP状态码#2xx成功)——请求已成功被服务器接收、理解、并接受。

  - 200: 正常返回信息

- [3xx重定向](https://zh.wikipedia.org/wiki/HTTP状态码#3xx重定向)——需要后续操作才能完成这一请求。

  - 300 Multiple Choices
  - **301 Moved Permanently：永久性重定向**。表示请求的资源已经被分配了新的 URI，以后应使用资源现在所指向的 URI。通常会发送 HTTP Location 来重定向到正确的新位置。这是将 HTTP 迁移到 HTTPS 的极佳方法。
  - **302 Found：临时重定向**。表示请求的资源已被分配了新的 URI，希望用户(本次)能使用新的 URI 访问。
  - 303 See Other：临时重定向。表示由于请求对应的资源存在着另一个 URI，应使用 **GET** 方法定向获取请求的资源。

  - **304 Not Modified：**表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。

  > 附带条件的请求是指采用 GET 方法的请求报文中包含 If-Match，If-Modified- Since，If-None-Match，If-Range，If-Unmodified-Since 中任一首部。

- [4xx请求错误](https://zh.wikipedia.org/wiki/HTTP状态码#4xx请求错误)——请求含有词法错误或者无法被执行，客户端错误。

  - 401 Unauthorized：请求未经授权，即用户没有权限执行这个请求。
  - 403 Forbidden：服务器收到请求，但是拒绝提供服务
  - 404 Not Found：请求资源不存在。最常见的就是URL错误

- [5xx服务器错误](https://zh.wikipedia.org/wiki/HTTP状态码#5xx服务器错误)——服务器在处理某个正确请求时发生错误

  - 500 Internal Server Error：表明服务器端在执行请求时发生了错误，有可能是 Web 应用存在的 bug 或某些临时的故障。
  - 502 Bad Gateway：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收了无效的响应。
  - 503 Service Unavailable：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

## HTTP 版本特性对比

**HTTP1.0**

- 短连接：每次发送请求都要重新建立 TCP 连接，即三次握手，数据发送完毕就要关闭连接。
- 无 host 头域，也就是 http 请求头里的 host。
- 不允许断点续传，而且不能只传输对象的一部分，要求传输整个对象。

**HTTP1.1**

- 引入了持久连接(persistent connectio)，又称长连接。客户端和服务器发现对方一段时间没有活动，可以主动关闭连接。
- 引入了流水线机制(pipelining)，也就是在同一个TCP连接里面，客户端可以同时发送多个请求。
- 采用"流模式"（stream）取代"缓存模式"（buffer），采用分块传输编码，产生一块数据，就发送一块。
- 客户端请求的头信息新增了 **Host 字段**，用来指定服务器的域名。
- 新增许多方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。
- 将 Content-length 字段的作用进行扩充，声明本次回应(Response)的数据长度。

> 虽然 HTTP1.1 允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为"队头堵塞"（Head-of-line blocking）。
>
> 为了避免这个问题，只有两种方法：**一是减少请求数，二是同时多开持久连接。**
>
> 这产生了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。

**HTTP1.x**的缺点

1. HTTP/1.0一次只允许在**一个TCP连接上发起一个请求**，HTTP/1.1 使用的流水线技术也只能**部分处理请求并发**，仍然会存在**队列头阻塞**问题，因此客户端在需要发起多次请求时，通常会采用建立**多连接**来减少延迟。
2. 单向请求，只能由客户端发起。
3. 请求报文与响应报文首部信息冗余量大。
4. 数据未压缩，导致数据的传输量大。

**HTTP2.0**

> 主要基于SPDY协议(Google开发的基于TCP协议的应用层协议)
>
> 核心思想是尽量减少TCP连接数。
>
> 目标是优化HTTP协议的性能，通过**压缩、多路复用和优先级**等技术，缩短网页的加载时间并提高安全性。
>
> 在不改动HTTP语义、方法、状态码、URI及首部字段的情况下，大幅度提高了 Web 性能。

- 改用**二进制传输**，HTTP1.x 使用文本传输。
  - 在应用层与传输层之间增加一个**二进制分帧层**，在二进制分帧层上，HTTP2.0 会将所有传输的信息分为更小的消息和帧，并采用二进制格式编码。
  - 其中 HTTP1.x 的首部信息会被封装到 **Headers帧**，而Request Body则封装到 **Data帧**。
- **头部(Header)压缩**：
  - 使用 HPACK (头部压缩算法)压缩格式对传输的 header 进行编码，减小了 header 的体积。
  - 在两端维护了索引表(Map)，用于记录出现过的header，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。
- **多路复用**：使用多个流(stream)，每个流分帧传输，使得一个 TCP 连接能够处理多个 HTTP 请求，避免 HTTP1.x版本的队头阻塞问题。
- **服务器端推送**Push：服务端可以在客户端某个请求后，主动推送其他资源。
- 更安全：使用了 TLS 的 拓展ALPN 作为协议升级，除此之外，HTTP2.0 对 TLS 的安全性做了近一步加强，通过黑名单机制禁用了几百种不再安全的加密算法。

**HTTP3.0**

- 基于 Google 的 QUIC 协议，利用UDP实现可靠数据传输。
- 减少了 TCP 三次握手时间，减少了 TLS 握手时间。
- 解决了 HTTP 2.0 中前一个 stream 丢包导致后一个 stream 被阻塞的问题。
- 优化了重传策略，重传包和原包的编号不同，降低后续重传计算的消耗。
- 连接迁移，不再用 TCP 四元组确定一个连接，而是用一个 64 位随机数来确定这个连接。
- 更合适的流量控制。

## HTTPS 工作流程

![简易版的HTTPS工作流程](https://tva1.sinaimg.cn/large/007S8ZIlly1gi0rcx6t6hj30hw0fldjy.jpg)

1. **客户端发起HTTPS请求**，连接到 Server 的 443 端口。

2. **服务器检测并选择客户端能支持的加密方式**

3. **传送证书**

   服务器将自己的数字证书的部分信息返回给客户端，其中包括公钥，以及支持的SSL 版本等信息。

4. **客户端解析证书**

   客户端首先会验证公钥是否有效，如果发现异常，则弹出警告。否则那么就生成一个随机值（Premaster Secret），然后用公钥对该随机值进行加密。

5. **传送加密信息**

   传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。

6. **服务端解密信息**

   服务端用与公钥配对的私钥解密后，得到客户端传过来的随机值。从客户端生成随机值到服务器解密获取随机值这个过程称为**非对称加密**。

7. **传输加密后的信息**

   服务器用刚刚解密得到的随机值加密需要传输的内容，并将加密后的信息发送给客户端。

8. **客户端解密信息**

   客户端用之前生成的随机值解密服务器传过来的信息，获取实际传输的内容。这个过程称为**对称加密**。

## SSL 协商过程

> 交换 9 个包，10 ~ 12 已经在进行数据传输。

![HTTPS通信](https://tva1.sinaimg.cn/large/007S8ZIlly1gi0rrhm2boj30k30og13g.jpg)

1. **客户端**发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件列表(所使用的加密算法及密钥长度等)。
2. **服务器**确定可进行 SSL 通信时，以 Server Hello 报文作为应答。报文中包含 SSL 版本以及加密组件(Cipher Suite)。服务器的加密组件内容是**从接收到的客户端加密组件内筛选出来的。**
3. **服务器**继续发送 Certificate 报文。报文中包含公钥证书。
4. **服务器**继续发送 ServerHelloDone 报文。通知客户端第一阶段的 SSL 握手协商部分结束。
5. **客户端**发送 Client Key Exchange 报文作为回应。报文中包含通信加密中一种被称为 `Pre-master secret`的随机密码串。这个报文已用第 3 步中的公钥进行加密。
6. **客户端**继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信都将会采用 `Premaster secret`秘钥加密。
7. **客户端**发送 Finished 报文。该报文包含连接至今，全部报文的整体校验值。此次握手协商能否成功，取决于服务器能否正确解密该报文。
8. **服务器**同样发送 Change Cipher Spec 报文。
9. **服务器**继续发送 Finished 报文。
10. 服务器与客户端交换完 Finished 报文之后，SSL 连接建立成功，通信将会受到 SSL 的保护。从此处开始进行**应用层协议**的通信，即发送 HTTP 请求。
11. **应用层协议**通信，即发送 HTTP 响应。
12. 由**客户端**断开连接。发送 close_notify 报文，之后发送 TCP FIN 报文来关闭与 TCP 的通信。

## 如何验证公钥证书

![证明公开密钥正确性的证书](https://tva1.sinaimg.cn/large/007S8ZIlly1gi0r9c0msvj30k60g0480.jpg)

## HTTPS 全流程图

下面是对整个流程的图解。图中说明了从仅使用服务器端的公开密钥证书(服务器证书)建立 HTTPS 通信的整个过程。

![HTTPS 通信全流程](https://tva1.sinaimg.cn/large/007S8ZIlly1gi0sk6p3nuj30jh0cb11y.jpg)

## HTTP 与 FTP 文件传输

![FTP使用两个TCP连接](https://gitee.com/raymond-zhao/oss/raw/master/uPic/image-20200930132601710.png)

> [断点续传](https://blog.csdn.net/liang19890820/article/details/53215087)

| Feature          | HTTP                                                         | FTP                                                          |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 侧重点           | 用来浏览网站、更多的是为终端用户提供文件传输，比如电影、图片、音乐。 | 用来访问和传输文件，FTP 文件传输常见于批量上传和维护网站。   |
| 客户端           | 通常是浏览器                                                 | 命令行或特定的图形界面                                       |
| 头部             | 包含 meta-data，比如最后修改日期、编码方式、服务器名称等。   | 不支持                                                       |
| 数据格式         | 只支持二进制格式文件                                         | 支持 ASCII 与二进制                                          |
| 流水线           | 支持流水线，这就意味着客户端可以在上一个请求处理完之前，发出下一个请求，其结果就是多次请求数据之前省掉了部分服务器客户端往返时延。 | 不支持                                                       |
| 动态端口         | 在双向传输中使用动态端口                                     | 使用两个连接，第一个连接用来发送控制指令，当接收或者发送数据的时候，又打开第二个TCP连接。 |
| 持久连接(长连接) | 可以维护一个单个的连接并使用它进行任意数量的数据传输。       | 每次有数据的需要时都创建一个新的连接。                       |
| 压缩算法         | 提供了在一些压缩算法中客户端和服务器共同协商选择的办法，比如 gzip。 | 不存在这种算法                                               |
| 对代理的支持     | 支持代理，这种功能是构建在协议里。                           | 不支持                                                       |
| 面向的对象       | 没有这个概念                                                 | 面向文件，ftp 可以通过命令列出远程服务器的目录列表。         |
| 文件大小         | 比较适合上传小文件                                           | 比较适合上传大文件，不需要将文件全部载入内存中。             |

**什么使 FTP 服务更快**

- 发送数据中没有`meta-data`，仅传输原始的二进制文件。
- 没有过度的分块编码。

**什么使 HTTP 服务更快？**

- 重用已存在的持久连接，从而有更好的TCP表现。
- 流水线的支持使得从同一个服务器上请求多个文件更快。
- 自动的压缩机制使得传输的数据更少。
- 没有命令/应答机制最大限度的减少了往返时延。

## Cookie 与 Session

**Cookie 简介：**

- 浏览器第一次连接服务器时 Cookie 是不存在的
- 服务器响应客户端时，会在 Header 中设置 Set-Cookie，服务器收到 Cookie 后存在本地。每一个 Cookie 都是 name-value 对。
- 此后浏览器再连接服务器，都会包含上 Cookie，服务器可以用它来关联特定的请求。

**Session 简介：**

- Cookie 是服务器用来实现 Session 的一种方式
- Cookie 中包含了 Session 的表示，通常被称为 SessionID。
- Session 的管理
  - 可以储存在内存里
  - 或者储存在磁盘中的文件中
  - 或者存在数据库中

> `Cookie` 和 `Session` 的区别

| 对比角度 | Cookie                                                       | Session                                                      |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 存放位置 | 位于客户端的一段文本、包含用户信息，是 Session 的一种实现方式。在 Tomcat 中 Cookie 的标准名为：JSESSIONID。 | 位于服务器的文件，包含用户信息。在 Tomcat 中使用 StandardSession 实现，使用到的数据结构是 ConcurrentHashMap。 |
| 生存时间 | 可以手动设定，浏览器可以删除老旧的 Cookies。                 | 当关闭浏览器时就消失。                                       |
| 容量大小 | 一般最大为 4KB，一个服务器可以通过不同的 Name 定义多个 Cookie，但是浏览器限制了每一个服务器可以拥有的 Cookie 数量(50个左右)。 | 理论上可以存储随意多的信息，唯一的限制是一个脚本一次最大能占用的内存，默认是 128MB。 |
| 依赖性   | Cookie 不依赖于 Session，Cookie 是 Session 的一种实现方式。  | Session 依赖于 Cookie，当 Cookie 禁用时，可以通过 URL 回写、URL 请求参数、FORM 隐藏字段等来实现。 |
| 安全性   | 相对较低                                                     | 相对较高                                                     |

## 

> [Tomcat 中的 Session 与 Cookie](https://juejin.im/post/6844903942288080903)

## Web 攻击技术

**主动攻击与被动攻击**

- **主动攻击**：攻击者通过直接访问 Web 应用， 把攻击代码传入的攻击模式。由于该模式是直接针对服务器上的资源进行攻击，因此攻击者需要能够访问到那些资源。
- **被动攻击**：是指利用圈套策略执行攻击代码的攻 击模式。在被动攻击过程中，攻击者不直接对目标 Web 应用访 问发起攻击。

### 跨站脚本攻击 XSS

**跨站脚本攻击(Cross-Site Scripting，XSS)**是指通过存在安全漏洞的 Web 网站注册用户的**浏览器内运行非法的 HTML 标签或 JavaScript** 进行的一种攻击。

防范措施：

- 输入过滤：根据业务需求，适当过滤掉`' " < > \ <!--`等特殊字符，尽量保证录入后端的数据可靠性；
- 输出过滤：同上，尽量保证输出到页面的数据可靠性；
- 开启浏览器自带的XSS防护：可以有效过滤很多低端钓鱼链接。

### 跨站请求伪造 CSRF

跨站请求伪造 CSRF（Cross-site request forgery）通过伪装来自受信任用户的请求来利用受信任的网站。**根本原因**是服务器对用户身份的过分信任或验证机制的不完善。

> 其他攻击方式：[Web安全](http://ramona-chen.top/cyhWebBook/Web%E5%AE%89%E5%85%A8.html)

## 同源策略与跨域问题

> 如果 Protocol:Host:Port 均相同，则两个 URL 同源，否则非同源。
>
> [浏览器的同源策略 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy)

