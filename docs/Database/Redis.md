## Redis 基本数据结构



## 使用缓存时可能出现的问题

> 推荐阅读：[妈妈再也不担心我面试被 Redis 问得脸都绿了](https://mp.weixin.qq.com/s/gmV0Z4nW9NYh4cVpDNiI9w)
>

一般来说有如下几个问题，回答思路遵照 **是什么** → **为什么** → **怎么解决**：

- 缓存雪崩问题；
- 缓存穿透问题；
- 缓存击穿问题；
- 缓存和数据库双写一致性问题。

### 缓存雪崩问题

![缓存雪崩](https://tva1.sinaimg.cn/large/007S8ZIlly1ghsnwdnqolj30tv0ft0zg.jpg)

另外对于 **"Redis 挂掉了，请求全部走数据库"** 这样的情况，有如下的思路：

- **事发前**：实现 Redis 的高可用(主从架构 + Sentinel 或者 Redis Cluster)，尽量避免 Redis 挂掉这种情况发生。
- **事发中**：万一 Redis 真的挂了，我们可以设置本地缓存(ehcache) + 限流(hystrix)，尽量避免我们的数据库被干掉(起码能保证我们的服务还是能正常工作的)
- **事发后**：Redis 持久化，重启后自动从磁盘上加载数据，快速恢复缓存数据。

### 缓存穿透问题

![缓存穿透](https://tva1.sinaimg.cn/large/007S8ZIlly1ghsnxrax6cj30tw0ft7aq.jpg)

### 缓存和数据库双写一致性问题

![缓存和数据库双写一致性问题](https://tva1.sinaimg.cn/large/007S8ZIlly1ghsnznkhp6j30tw0fqgt6.jpg)

> 本系统的一致性解决方案：
>
> - 为所有缓存数据设置过期时间，数据过期下一次查询触发主动更新。
> - 读写数据的时候，加上分布式的读写锁。(读多写少时几乎无影响)

无论是双写模式还是失效模式，都会导致缓存的不一致问题，即多个实例同时更新会出事，怎么办?

- 如果是**用户维度**数据(订单数据、用户数据)，这种并发几率非常小，不用考虑这个问题，缓存数据加 上过期时间，每隔一段时间触发读的主动更新即可。
- 如果是菜单，商品介绍等**基础数据**，也可以去使用 `canal` 订阅 `binlog` 的方式。
- **缓存数据 + 过期时间** 足够解决大部分业务对于缓存的要求。
- 通过**加锁**保证并发**读写、写写**的时候按顺序排好队，读读无所谓，所以适合使用读写锁。(业务不关心 脏数据，允许临时脏数据可忽略)

**总结:**

- 能放入缓存的数据本就不应该是实时性、一致性要求超高的。所以缓存数据的时候加上过期时间，保

  证每天拿到当前最新数据即可。

- 不应该过度设计，增加系统的复杂性。

- 遇到实时性、一致性要求高的数据，就应该实时直接查数据库，即使这样速度相对于缓存会比较慢。

> 推荐阅读：[面试前必须要知道的Redis面试题](https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484609&idx=1&sn=4c053236699fde3c2db1241ab497487b&scene=21#wechat_redirect)

### 缓存击穿

- 是什么：在高并发的系统中，大量的请求同时查询一个 `key`(热点 `key`) 时，此时这个 `key` 正好失效了，就会导致大量的请求都打到数据库上面去。
- 为什么：`key` 设置了过期时间，`key` 又为热点`key`
- 怎么解决：在第一个查询数据的请求上使用一个 **互斥锁(mutex)** 来锁住它。其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。

```java
public String get(key) {
    String value = redis.get(key);
    if (value == null) { // 代表缓存值过期
        // 设置 3min 的超时，防止 del 操作失败的时候，下次缓存过期一直不能load db
        if (redis.setnx(key_mutex, 1, 3 * 60) == 1) {  //代表设置成功
            value = db.get(key);
            redis.set(key, value, expire_secs);
            redis.del(key_mutex);
        } else {  
            // 这个时候代表同时候的其他线程已经load db并回设到缓存了
            // 这时候重试获取缓存值即可
            sleep(50);
            get(key);  //重试
        }
    } else return value;
 }
```

> 这种 **互斥锁(mutex) ** 在单机情况下是有效的，但是在分布式情况下就要使用**分布式锁**。
>
> 本地锁，只能锁住当前线程，所以需要分布式锁。
>
> Spring Boot 所有的组件在容器中默认都是单例的，使用 `synchronized (this)` 可以实现加锁。
>
> 在每一个微服务中的`synchronized(this)`加锁的对象只是当前实例，但是并未对其他微服务的实例产生影响，即使每个微服务加锁后只允许一个请求，假如有 8 个微服务，仍然会有 8 个线程存在。

## 如何保证在查询缓存时只查一次DB

```java
/**
* SpringBoot 所有的组件在容器中默认都是单例的，使用 synchronized (this) 可以实现加锁。
*
* 得到锁之后 应该再去缓存中确定一次，如果没有的话才需要继续查询。
*
* 假如有100W个并发请求，首先得到锁的请求开始查询，此时其他的请求将会排队等待锁
* 等到获得锁的时候再去执行查询，但是此时有可能前一个加锁的请求已经查询成功并且将结果添加到了缓存中
*/
```

将核心操作封装为原子操作，保证锁的时序性，具体地讲，就是将

1. 确认缓存是否存在
2. 查询数据库
3. 将结果放入缓存

这三个操作封装为原子操作，必须当做一个事务来执行，放在同一把锁里面完成。