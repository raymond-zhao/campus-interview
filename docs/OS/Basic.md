## 进程通信类型

## 进程通信方式

## 进程同步方式

## 进程调度算法

- **先来先服务调度算法(FCFS)**
  - 既可用于作业调度，也可用于进程调度。
  - 作业调度中：每次从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。
  - 进程调度中：每次从就绪队列中选择一个最先进 入该队列的进程，为之分配处理机，使之投入运行，直到其运行完成或阻塞而退出。
  - 有利于长作业(进程)，而不利于短作业(进程)。

- **短作业(进程)优先调度算法(SJ(P)F)**

  - 对短作业或短进程优先调度的算法
  - 短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。
  - 短进程优先(SPF)调度算法则是从就绪队列中选出一个估计运行时间最短的进程，将处理机分配给它，直到其运行完成或阻塞而退出。
  - SJF 调度算法能有效地降低作业的平均等待时间，提高系统吞吐量。
  - 缺点：
    - 对长作业不利；
    - 完全未考虑作业的紧迫程度，因而不能保证紧迫性作业(进程)会被及时处理；
    - 由于作业(进程)的长短只是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。 

- **高优先权优先调度算法**

  - $$
    优先权=\frac{等待时间+要求服务时间}{要求服务时间} =\frac{响应时间}{要求服务时间}
    $$

  - 如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而该算法有**利于短作业**。

  - 当要求服务的时间相同时，作业的优先权决定于其等待时间，等待时间愈长，其优先权愈高，因而它实现的是**先来先服务**。

  - 对于**长作业**，作业的优先级可以随等待时间的增加而提高，当其等待时间足够长时，其优先级便可升到很高，从而也可获得处理机。

- **基于时间片的轮转调度算法**

  - **时间片轮转法：**
    - 系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把 CPU 分配给队首进程，并令其执行一个时间片。
  - **多级反馈队列调度算法：**
    - 设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高， 第二个队列次之，其余各队列的优先权逐个降低。
    - 各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。
    - 当一个新进程进入内存后，首先将它放入第一队列的末尾，按 FCFS 原则排队等待调度。
      - 如它能在该时间片内完成，便可准备撤离系统；否则，调度程序便将该进程转入第二队列的末尾，再同样地按 FCFS 原则等待调度执行。
    - 仅当上一级队列空闲时，调度程序才调度下一级队列中的进程运行。

- **实时调度算法**

  - **最早截止时间优先即 EDF(Earliest Deadline First)算法（贪心思想）**
  - **最低松弛度优先即 LLF(Least Laxity First)算法**

## 页面置换算法

- **最佳(Optimal)置换算法：**
  - 理论上的算法，实际上不可行。
  - 其所选择的被淘汰页面， 将是以后永不使用的，或许是在最长(未来)时间内不再被访问的页面。
- **先进先出(FIFO)页面置换算法：**
  - 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。
  - 算法实现简单，只需把一个进程已调入内存的页面，按先后次序链接成一个队列，并设置一个指针，称为**替换指针**，使它**总指向最老的页面**。
  - 缺点：性能差，依据条件是各个页面调入内存的时间， 而页面调入的先后并不能反映页面的使用情况。
- **最近最久未使用(LRU)置换算法：**
  - 根据页面调入内存后的使用情况进行决策。选择最近最久未使用的页面予以淘汰。
  - 赋予每个页面一个访问字段，用来记录一个页面**自上次被访问以来所经历的时间** t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最久未使用的页面予以淘汰。
  - 硬件支持：寄存器或栈。
- **最少使用(LFU:Least Frequently Used)置换算法：**
  - 在内存中的每个页面设置一个移位寄存器，用来记录该页面**被访问的频率**。
  - 该置换算法选择在**最近时期使用最少的页面**作为淘汰页。
- **页面缓冲算法(PBA:Page Buffering Algorithm)：**
  - 该算法规定将一个被淘汰的页放入两个链表中的一个，即如果页面未被修改，就将它直接放入**空闲链表**中；
  - 否则，便放入已**修改页面的链表**中。
- **Clock 置换算法：**LRU 的近似算法。
  - 为每页设置一位访问位，再将内存中的所有页面都**通过链接指针链接成一个循环队列**。
  - 当某页被访问时，其访问位被置 1。
  - 置换算法在选择一页淘汰时，只需检查页的访问位。**如果是 0**，就选择该页换出；**若为 1**，则重新将它置 0，暂不换出，而给该页第二次驻留内存的机会，再按照 FIFO 算法检查下一个页面。
  - 当检查到队列中的最后一个页面时，若其访问位仍为 1，则再返回到队首去检查第一个页面。
  - **由于该算法是循环地检查各页面的使用情况，故称为 Clock 算法。**
  - 但因该算法只有一位访问位，只能用它表示该页是否已经**使用过**，而置换时是将**未使用过**的页面换出去，故又把该算法称为**最近未用算法 NRU**(Not Recently Used)。
- **改进型 Clock 置换算法：**
  - 在将一个页面换出时，如果该页已被修改过，便须将该页重新写回到磁盘上；
  - 但如果该页未被修改过，则不必将它拷回磁盘。

## 产生死锁的原因

- **竞争资源：**当系统中供多个进程共享的资源其数目不足以满足众多进程的需要时，会引起这些进程对资源的竞争而产生死锁。
- **进程间推进顺序非法：**进程在运行过程中，请求和释放资源的顺序不当，也会导致产生进程死锁。

## 产生死锁的必要条件

- **互斥条件：**指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求该资源，则请求者只能等待，直至占有该资源的进程用毕释放。
- **请求和保持条件：**指进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又已被其它进程占有，此时请求进程阻塞，但仍对已获得的其它资源保持不放。
- **不剥夺条件：**指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
- **环路等待条件：**指在发生死锁时，必然存在一个进程—资源的环形链。

## 预防死锁的方法

破坏上面四条件之一即可避免发生死锁。

- 破坏“互斥条件”：不可行，因为它是由设备的固有特性所决定的，不仅不能改变，还应加以保证。
- 破坏“请求和保持”条件：所有进程在开始运行之前，都必须一次性地申请其在整个运行过程所需的全部资源。
- 破坏“不剥夺”条件：当一个已经持有某些资源的进程，再提出新的资源请求而不能立即得到满足时，首先释放它已持有的所有资源，待以后需要时再重新申请。
- 破坏“环路等待”条件：所有资源按类型进行线性排队，按序申请。

## 处理死锁的方法

- **预防死锁：**破坏产生死锁的四个必要条件中的一个或几个条件，来预防发生死锁。
- **避免死锁：**不必事先采取措施去破坏产生死锁的必要条件，而是在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免发生死锁。
- **检测死锁：**不必事先采取任何限制性措施，也不必检查系统是否已经进入不安全区，而是允许系统在运行过程中发生死锁。但可通过系统所设置的检测机构，及时地检测出死锁，并精确定位与死锁有关的进程和资源; 然后，采取适当措施，从系统中将已发生的死锁清除掉。
- **解除死锁：**当检测到系统中死锁时，须将进程从死锁状态中解脱出来。常用的实施方法是撤消或挂起一些进程，以便回收资源，再将这些资源分配给已处于阻塞状态的进程，使之转为就绪状态，以继续运行。

## 银行家算法

作用：避免死锁。

> 银行家算法的数据结构

- **可利用资源向量 Available：**
  - 含有 $m$ 个元素的数组，其中的每一个元素代表一类可利用的资源数目。
  - 初始值是系统中所配置的该类全部可用资源的数目，其数值随该类资源的分配和回收而动态地改变。
  - 如果 $Available[j]=K$，则表示系统中现有 $R_j$ 类资源 $K$ 个。
- **最大需求矩阵 Max：** 
  - $n \times m$ 的矩阵；
  - 它定义了系统中 $n$ 个进程中的每一个进程对 $m$ 类资源的最大需求。
  - 如果 $Max[i,j]=K$，则表示进程 $i$ 需要 $R_j$ 类资源的最大数目为 $K$。
- **分配矩阵 Allocation：**
  -  $n×m$ 的矩阵；
  - 它定义了系统中每一类资源当前已分配给每一进程的资源数。
  - 如果 $Allocation[i,j]=K$，则表示进程 $i$ 当前已分得 $R_j$ 类资源的数目为 $K$。
- **需求矩阵 Need：**
  -  $n×m$ 的矩阵；
  - 表示每一个进程尚需的各类资源数。
  - 如果 $Need[i,j]=K$，则表示进程 $i$ 还需要 $R_j$ 类资源 $K$ 个，才能完成其任务。

**上述三个矩阵之间的关系：**
$$
Need[i, j]=Max[i, j]-Allocation[i, j]
$$

> 银行家算法

设 $Request_i$ 是进程 $P_i$ 的请求向量，如果 $Request_i[j]=K$，表示进程 $P_i$ 需要 $K$ 个 $R_j$ 类型的资源。当 $P_i$ 发出资源请求后，系统按下述步骤进行检查：

1. 如果 $Request_i[j]\le Need[i,j]$，便转向步骤(2)；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。
2. 如果 $Request_i[j] \le Available[j]$，便转向步骤(3)；否则，表示尚无足够资源，$P_i$ 须等待。
3. 系统尝试把资源分配给进程 $P_i$，并修改以下数据结构中的数值：

$$
Available[j] := Available[j] - Request_i[j]; \\
Allocation[i,j] := Allocation[i,j] + Request_i[j]; \\
Need[i,j] := Need[i,j] - Request_i[j];
$$

4. 系统执行**安全性算法**，检查此次资源分配后系统是否处于安全状态。
   1. 若安全，才正式将资源分配给进程 $P_i$，以完成本次分配；
   2. 否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程 $P_i$ 等待。

