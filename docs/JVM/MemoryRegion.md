## 运行时数据区

<img src="https://tva1.sinaimg.cn/large/00831rSTly1gdhy19il1mj312s0u0k6g.jpg" alt="运行时数据区" style="zoom:67%;" />

> 线程私有：**虚拟机栈、本地方法栈、程序计数器**；
>
> 线程共享：**堆，方法区**。

### 程序计数器

- 程序计数器(Program Counter Register)是一块较小的内存空间；
- 可以看作是当前线程所执行的**字节码的行号指示器**，**字节码解释器**工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令；
- 它是程序控制流的指示器，**分支、循环、跳转、异常处理、线程恢复**等基础功能都需要依赖这个计数器来完成。
- 如果线程正在执行的是**Java方法**，这个计数器记录的是正在执行的虚拟机**字节码指令的地址**。
- 如果正在执行的是**本地(Native)方法**，这个计数器值则应为**空(Undefined)**。
- 此内存区域是唯一一个没有规定任何 OOM 情况的区域。

### 虚拟机栈

- 每个方法被执行的时候，Java虚拟机都会同步创建一个**栈帧**用于存储**局部变量表、操作数栈、动态连接、方法出口**等信息。
- 每一个方法被**调用直至执行完毕的过程**，就对应着一个**栈帧在虚拟机栈中从入栈到出栈的过程。**
- **局部变量表**存放了各种**基本数据类型**(boolean、byte、char、short、int、float、long、double)、**对象引用**(reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的**句柄**或者其他与此对象相关的位置)和**return Address类型**(指向了一条字节码指令的地址)。
- 这个内存区域有**两类异常状况**：
  - 如果线程请求的栈深度**大于虚拟机所允许的深度**，将抛出`StackOverflowError`异常；
  - 如果Java虚拟机栈容量可以动态扩展，当栈扩展时**无法申请到足够的内存**会抛出`OutOfMemoryError`异常。

### 本地方法栈

- 本地方法栈(Native Method Stacks)与虚拟机栈所发挥的作用非常相似，区别只是虚拟机栈为虚拟机执行Java方法(也就是字节码服务，而本地方法栈则是为虚拟机使用到的本地(Native)方法服务。


- 与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出`StackOverflowError`和`OutOfMemoryError`异常。

### 堆 Heap

- 虚拟机所管理的内存中**最大的**一块，被所有线程所共享，在虚拟机启动时创建；
- 此内存区域的**唯一目的**就是存放**对象实例**；
- 从**分配内存的角度**看，所有线程共享的 Java 堆中可以划分出多个线程私有的**分配缓冲区**(ThreadLocalAllocationBuffer，TLAB)，以提升对象分配时的效率。
- Java 堆可以处于物理上不连续的内存空间中，但在逻辑上应该被视为连续的。
- Java 堆既可以被实现成固定大小的，也可以是可扩展的(通过参数`-Xmx`和`-Xms`)。
- 如果在 Java 堆中没有内存完成实例分配，并且堆也无法再扩展时，Java 虚拟机将会抛出 OutOfMemoryError 异常。

### 方法区

- 线程共享，用于存储已被虚拟机加载的**类型信息、常量、静态变量、即时编译器编译后的代码缓存**等数据。
- 和 Java 堆一样不需要连续的内存，也可以选择固定大小或者可扩展。
- 这区域的内存回收目标主要是针对**常量池的回收**和对**类型的卸载**。
- 如果方法区无法满足新的内存分配需求时，将抛出`OutOfMemoryError`异常。

### 运行时常量池

- 方法区的一部分。
- Class 文件中除了有**类的版本、字段、方法、接口**等描述信息外，还有一项信息是**常量池表**(ConstantPoolTable)，用于存放编译期生成的各种**字面量**与**符号引用**，这部分内容将在类加载后存放到**方法区的运行时常量池**中。

### 直接内存

- 不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致`OutOfMemoryError`异常出现。

## 创建对象有哪些方式？

- 使用 `new` 关键字；
- 使用 Class 类的 newInstance() 方法。`User user = User.class.newInstance();`
- 使用 Constructor 类的 newInstance() 方法。`User user = User.class.getConstructor().newInstance();`
- 使用 Clone() 方法；
- 使用反序列化。

### new 的过程发生了什么？

1. 当 Java 虚拟机遇到一条字节码 `new` 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的**符号引用**，并且检查这个符号引用代表的类是否已被**加载、解析和初始化**过。如果没有，那必须先执行相应的**类加载过程**。
2. 在类加载检查通过后，将会在**堆(Heap)**上为新生对象**分配内存**，分配内存的方式可以选择**指针碰撞**或者**空闲列表**。
   - **指针碰撞**：假设 Java 堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离。
   - **空闲列表**：如果 Java 堆中的内存并不规整，已被使用的内存和空闲的内存相互交错，没有办法简单地进行指针碰撞了，虚拟机维护一个列表，记录上哪些内存块可用，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

3. 内存分配完成之后，虚拟机将分配到的对象头以外的内存空间都**初始化为零值**。
4. **对对象进行必要的设置**，例如这个对象是哪个类的实例、类元信息、对象的哈希码、GC分代年龄等信息。这些信息存放在对象的**对象头(Object Header)**之中。
5. 执行`<init>()`方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。

总结一下，对象的创建大致为：

1. 类加载检查
2. 分配内存
3. 将新分配的内存初始化为零值
4. 设置对象头
5. 执行Class文件中的`<init>()` 方法

> 解决对象创建时可能出现的**线程不安全**这个问题有两种可选方案:
>
> - 一种是对分配内存空间的动作进行同步处理—实际上虚拟机是采用**CAS配上失败重试**的方式保证更新操作的原子性；
> - 一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为**本地线程分配缓冲**(Thread Local Allocation Buffer，TLAB)，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。虚拟机是否使用TLAB，可以通过`-XX:+/-UseTLAB`参数来设定。