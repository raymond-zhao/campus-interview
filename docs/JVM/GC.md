## 如何判断对象是否可以被清除？

1. 引用计数法(Redis 用了这个)：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。**无法解决相互循环引用。**
2. 可达性分析法：通过一系列被称为 **GC Roots** 的根对象作为起始点集合，从这些节点开始根据引用关系向下搜索，搜索过程走过的路径被称为“**引用链**”，如果某个对象到 GC Roots 之间没有任何引用链，那这个对象就是不可能再被使用的。

## 哪些对象可以当做 GC Roots？

1. 在**虚拟机栈**(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
2. 在**方法区中类静态属性引用的对象**，譬如 Java 类的引用类型静态变量。
3. 在**方法区中常量引用的对象**，譬如字符串常量池(String Table)里的引用。
4. 在**本地方法栈中 JNI**(即通常所说的Native方法)引用的对象。
5. Java **虚拟机内部的引用**，如基本数据类型对应的 Class 对象，一些常驻的异常对象(比如`NPE、OOM`)等，还有系统类加载器。
6. 所有被**同步锁(synchronized关键字)持有的对象**。
7. 反映 Java 虚拟机内部情况的 JMXBean、JVM TI 中注册的回调、本地代码缓存等。

## 四大引用

- 强引用(Strong Reference)
  - 最普遍的引用：`Object obj = new Object();`
  - 抛出`OutOfMemoryError`终止程序也不会回收具有强引用的对象。
  - 通过将对象设置为`null`来软化引用，使其被回收。
- 软引用(Soft Reference)
  - 对象处在有用但非必须的状态。
  - 只有当内存空间不足时，GC 才会回收该引用的对象的内存。
  - 可以用来实现**高速缓存**。
- 弱引用(Weak Reference)
  - 非必须的对象，比软引用更弱一些。
  - GC 时会被回收。
  - 被回收的概率也不大，因为 GC 线程优先级比较低。
  - 适用于引用偶尔被使用且不影响垃圾收集的对象。
- 虚引用(Phantom Reference)
  - 不会决定对象的生命周期。
  - 任何时候都可能被 GC 回收。
  - 跟踪对象被垃圾收集器回收的活动，起哨兵的作用。
  - 必须和引用队列`ReferenceQueue`联合使用。

| 引用类型 | 被垃圾回收时间 |      用途      |     生存时间      |
| :------: | :------------: | :------------: | :---------------: |
|  强引用  |    从来不会    | 对象的一般状态 | JVM停止运行时终止 |
|  软引用  |   内存不足时   |    对象缓存    |  内存不足时终止   |
|  弱引用  |   垃圾回收时   |    对象缓存    |   GC 运行后终止   |
|  虚引用  |     不确定     |   标记、哨兵   |      不确定       |

- 引用队列(Reference Queue)
  - 无实际存储结构，存储逻辑依赖于内部节点之间的关系来表达。
  - 存储关联的且被 GC 的软引用，弱引用以及虚引用。

## 回收方法区

方法区的垃圾收集主要回收两部分内容: **废弃的常量**和**不再使用的类型**。

判定一个常量是否“废弃”相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就需要同时满足下面三个条件:

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类及其任何派生子类的实例。
- 加载该类的类加载器已经被回收。
- 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

## 垃圾收集算法

### 标记-清除算法

**工作过程：**

- 首先标记出所有需要回收的对象；
- 在标记完成后，统一回收掉所有被标记的对象；
- 也可以反过来，标记存活的对象，统一回收所有未被标记的对象。
- 标记过程就是判定对象否属于垃圾的过程。

主要缺点：

- 执行效率不稳定，如果 Java 堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低。
- 内存空间的**碎片化问题**，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中**需要分配较大对象时**无法找到足够的连续内存而不得不**提前触发**另一次垃圾收集动作。

### 标记-复制算法

**工作过程：**

- 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。
- 当一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
- 分配内存时也就不用考虑**空间碎片**的复杂情况，只要移动**堆顶指针**，按顺序分配即可。

**主要缺点：**

- 在对象存活率较高时就要进行较多的复制操作，效率将会降低。


- 将**可用内存缩小为了原来的一半，空间浪费太多。**现在常用的是 Eden: From Survivor: To Survivor = 8:1:1。

### 标记-整理算法

**工作过程：**

- “标记-整理”(Mark-Compact)算法中的标记过程仍然与“标记-清除”算法一样；
- 但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都**向内存空间一端移动**，然后直接清理掉边界以外的内存。

## 经典垃圾收集器

![HotSpot虚拟机的垃圾收集器](https://cdn.jsdelivr.net/gh/raymond-zhao/pictures@main/uPic/image-20230516073732595.png)



### CMS 收集器

CMS(Concurrent Mark Sweep) 收集器是一种以**获取最短回收停顿时间**为目标的收集器。

CMS 收集器是基于**标记-清除**算法实现的，它的运作过程分为四个步骤，包括:

- **初始标记(**CMS initial mark)：标记GC Roots能直接关联到的对象。
- **并发标记**(CMS concurrent mark)：从GC Roots的直接关联对象开始遍历整个对象图，耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。
- **重新标记**(CMS remark)：为了修正并发标记期间，因用户程序继续运行而导致标记产生变动的那部分对象。停顿时间通常会比初始标记阶段稍长，但远比并发标记阶段的时间短。
- **并发清除**(CMS concurrent sweep)：清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也可以与用户线程同时并发。

> 其中**初始标记、重新标记**这两个步骤仍然需要“Stop The World”。

### CMS 的缺点

- CMS收集器对处理器**资源非常敏感**，CMS 默认启动的回收线程数是(处理器核心数量 +3)/4。
- 无法处理“**浮动垃圾**”，有可能出现“Concurrent Mode Failure”失败进而导致另一次 Full GC 。
  - 适当调高参数`-XX:CMSInitiatingOccupancyFraction`可以解决。
- 基于“**标记-清除**”算法，可能会产生大量空间碎片，给**大对象分配**带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次 Full GC 的情况。
  - `-XX:+UseCMSCompactAtFullCollection`：在 CMS 不得不进行 Full GC 时开启**内存碎片的合并整理**过程，由于这个内存整理必须移动存活对象，**解决了空间碎片问题，但停顿时间又会变长**。
  - `-XX:CMSFullGCsBeforeCompaction`：要求 CMS 在执行过若干次不整理空间的 Full GC 之后，下一次进入 Full GC 前会先进行碎片整理(默认值为0，表示每次进入FullGC时都进行碎片整理)。

> **浮动垃圾: ** 在 CMS 的并发标记和并发清理阶段，用户线程仍在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在**标记过程结束以后**，CMS 无法在当次收集中处理掉它们，只好下一次垃圾收集时再清理掉。

### G1

G1 面向堆内存任何部分组成**回收集**来进行回收，衡量标准不再是它属于哪个分代，而是**哪块内存中存放的垃圾数量最多，回收收益最大**。

- 设计思路：面向**局部收集**。
- 内存布局：基于 **Region** 的内存布局。每个 Region 都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间。

**工作过程：**

- **初始标记**：标记 GC Roots 能直接关联到的对象，修改 **TAMS指针** 的值。需要停顿线程，但耗时很短，而且是借用进行 Minor GC 时同步完成的，所以此阶段实际并没有额外的停顿。
- **并发标记**：从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，耗时较长，但可与用户程序**并发**执行。当对象图扫描完成以后，还要重新处理 SATB 记录下的在并发时有引用变动的对象。
- **最终标记**：对用户线程做另一个短暂的暂停，用于处理并发标记阶段结束后仍遗留下来的少量的 SATB 记录。
- **筛选回收**： 
  - 更新 Region 的统计数据，对各个 Region 的回收价值和成本进行排序；
  - 根据用户所期望的停顿时间制定回收计划，自由选择任意多个 Region 构成**回收集**；
  - 把决定回收的那部分 Region 中的存活对象复制到空的 Region 中(**复制**)；
  - 清理掉整个旧 Region 的全部空间；
  - 以上操作涉及存活对象的移动，必须暂停用户线程，由多条收集器线程并行完成的。

从上面可以看出，G1

- **整体上**基于**标记-整理算法**实现；
- **局部(两个 Region 之间)**角度看是基于**标记-复制算法**实现。

> 在并发标记阶段如何保证收集线程与用户线程互不干扰地运行?
>
> - CMS收集器采用**增量更新**算法
> - G1收集器则是通过**原始快照**(SATB)算法

## 低延迟垃圾收集器

### Shenandoah

Shenandoah 与 G1 的区别：

- 支持并发的整理算法不同。
- Shenandoah 没有专门的新生代 Region 或者老年代 Region 的存在，不存在分代。
- 放弃了记忆集，改用连接矩阵。

**Shenandoah 工作的九个过程：**

- 初始标记(Initial Marking)：标记与GC Roots直接关联的对象，仍需 STW，但停顿时间与堆大小无关，只与GC Roots的数量相关。
- 并发标记(Concurrent Marking)：遍历对象图，标记出全部可达的对象。与用户线程并发，用时取决于堆中存活对象的数量以及对象图的结构复杂程度。
- 最终标记(Final Marking)：处理剩余的SATB扫描，统计出回收价值最高的Region，构造回收集。
- 并发清理(Concurrent Cleanup)：用于清理那些整个区域内连一个存活对象都没有找到的Region。
- 并发回收(Concurrent Evacuation)：把回收集里面的存活对象先复制一份到其他未被使用的Region之中。时间取决于回收集的大小。
- 初始引用更新(Initial Update Reference)：把堆中所有指向旧对象的引用修正到复制后的新地址。
- 并发引用更新(Concurrent Update Reference)：真正开始进行引用更新操作，时间长短取决于内存中涉及的引用数量的多少。它不再需要沿着对象图来搜索，只需要按照内存物理地址的顺序，线性地搜索出引用类型，把旧值改为新值即可。
- 最终引用更新(Final Update Reference)：修正存在于 GC Roots 中的引用。
- 并发清理(Concurrent Cleanup)：回收Region的内存空间，供以后新对象分配使用。

## 参考

- [垃圾收集算法](https://raymond-zhao.top/2020/08/19/2020-08-19-JVM-GC/)