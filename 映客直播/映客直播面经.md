# 映客直播面经

## 笔试

### 单选

```
1、以下有关事务持续性的说法正确的是
A 事务一旦提交，其对数据库的修改是永久性的
B 事务中的操作要么全做，要么全不做
C 并发执行的各个事务之间不能相互干扰
D 事务的执行必须将数据库从一个一致性状态转换到另一个一致性状态

2、已知一个线性表{23,43,27,54,89,75,64,34},假定采用散列函数 h(key) = key % 9 计算散列地址，并散列存储在散列表 A[0...8] 中，若采用线性探测方法解决冲突，则在该散列表上进行等概率成功查找的平均查找次数是
A 0
B 1.5
C 2.25
D 1.75

3、对序列{45，68，55，39，40，74}进行快速排序时，以第一个元素45作为基准的一次划分结果为
A {40,39,45,55,68,74}
B {40,68,55,39,45,74}
C {39,40,45,55,68,74}
D {40,39,55,45,68,74}

4、主机甲向主机乙发送一个{SYN = 1, seq = 1500}的TCP段，期望与主机乙建立TCP连接，若主机乙接受该连接请求，则主机乙向主机甲发送的正确的TCP段可能是
A (SYN = 1，ACK = 1，seq = 1500, ack = 1500)
B (SYN = 1，ACK = 0，seq = 1501, ack = 1501)
C (SYN = 0，ACK = 1，seq = 1500, ack = 1500)
D (SYN = 1，ACK = 1，seq = 1501, ack = 1501)

5、一下说法正确的是
A 在使用AJAX请求时，GET请求不会触发跨域
B HTTP/1.1 中的 keep-alive 是一个通用消息头，用于标识资源的缓存状态
C REStful 指的是使用GET、POST、HEAD、DELETE 4种请求方式对服务端资源进行操作
D HTTP/2 中的多路复用（MultiPlexing）指的是多个请求可同时在一个连接上并行执行

6、一个人要受人尊敬，首先必须保持自尊；一个人，只有问心无愧，才能保持自尊；而一个人如果不恪尽职守，就不能问心无愧，那么：
I 一个受人尊敬的人，一定恪尽职守； II 一个问心无愧的人，不可能受人尊敬；III 一个恪尽职守的人，一定保持自尊
A 只有II 和 III
B 只有I 和 II
C I、II 和III
D 只有I 和 III

7、箱子里有红色的球40个，蓝色的球60个。A、B两人玩游戏，A闭着眼睛从箱子中随机拿出一个球，B告诉A球的颜色，但是B有30%的几率会撒谎，A如果相信游戏结束，A如果不相信继续从箱子里拿，游戏规定拿到红色的球算胜利，请问A获胜的概率是什么
A 46%
B 40%
C 没有正确答案
D 28%

8、以下关于http协议说法错误的是
A 5xx全部都是服务端的问题
B http协议对请求body大小没有限制
C 使用http协议可以传输视频文件
D 使用https就可以保证数据安全
```

### 多选(两道)

```
1. 以下关于TCP和UDP的说法错误的是
A TCP协议未收到ACK确认的数据包都会重发
B UDP的传输效率比TCP高
C TCP协议发送窗口的大小是由接收方的窗口大小决定的
D UDP的头部开销比TCP小

2. 忘记了
```

### 编程题(四道)

#### 1. 取平方数

```
一个有序整数数组，返回对数组中所有不同的数取平方有多少种不同的取值。
```

```java
/**
* 这种思路最简单，因为相反数的绝对值取平方后相等，而Set又有去重的功能。
* 所以 时间复杂度 O(n), 空间复杂度 O(n)
* 不是最优解
*/
public int numOfSquare (int[] arr) {
    // write code here
    if (arr == null || arr.length == 0) return 0;
    Set<Integer> set = new HashSet<>();
    for (int num : arr)
        set.add(Math.abs(num));
    return set.size();
}
```

```java
/**
* 上面的解法没有利用数组有序这个条件
* 可改进为 O(n), O(1) 的解法
* A，B 的绝对值相等有两种情况，一是 A = B，二是 A = -B
*/
public int numOfSquare (int[] arr) {
    // write code here
    if (arr == null || arr.length == 0) return 0;
    int res = 0;
    int left = 0, right = arr.length - 1;
    while (left <= right) {
        int leftNum = Math.abs(nums[left]);
        int rightNum = Math.abs(nums[right]);
        if (leftNum > rightNum) {
            res++; // 绝对值不等，平方必然不等，++
            while (left <= right && Math.abs(nums[left]) == leftNum) left++; // 跳过相等值
        } else if (leftNum < rightNum) {
            res++;
            while (left <= right && Math.abs(nums[right]) == rightNum) right--; // 跳过相等值
        } else {
            res++;
            while (left <= right && Math.abs(nums[left]) == leftNum) left++;
            while (left <= right && Math.abs(nums[right]) == rightNum) right--;
        }
    }
    return res;
}
```

#### 2. 约瑟夫环

```
忘记具体题目是什么了，扫了一眼题就感觉是约瑟夫环。
当时模模糊糊地记得LeetCode有逆推的解法，但是只是模模糊糊。

n 个人(n < 1000) 围成一个圈，顺序排号。从第一个人开始从1到3报数，报到3的人退出。问最后剩下的人原来的编号是多少。
```

```java
/**
* 暴力解法，又称模拟法。
* O(n) O(n)
*/
public int survival (int n) {
    // write code here
    List<Integer> start = new ArrayList<>();
    int res = 0;
    for (int i = 1; i <= n; i++)
        start.add(i); // 先生成所有的人，让他们坐成一圈。
    int k = 0; // 初始从第 0 个人开始报数
    while (start.size() > 0) { // 只有还有人存在，那就继续。
        k += 3; // 下一个报数的人的编号
        k = k % (start.size()) - 1;
        if (k < 0) {
            res = start.get(start.size() - 1);
            start.remove(start.size() - 1);
            k = 0;
        } else {
            res = start.get(k);
            start.remove(k);
        }
    }
    return res;
}

/**
* 逆推 
* 剑指Offer 62
*/
public int survival (int n) {
    int res = 0;
    for (int i = 2; i <= n; i++)
        res = (res + 3) % i;
    return res;
}
```

#### 3. 比较版本号

```
牛客上的原题，换了个说法，描述了一个具体工作的场景。

如果version1 > version2 返回1，如果 version1 < version2 返回-1，不然返回0.

输入的version字符串非空，只包含数字和字符.。.字符不代表通常意义上的小数点，只是用来区分数字序列。例如字符串2.5并不代表二点五，只是代表版本是第一级版本号是2，第二级版本号是5.
```

```java
/**
* 比较版本
* @param version1 string字符串 版本1
* @param version2 string字符串 版本2
* @return int整型
*/
public int compareVersion (String version1, String version2) {
    // write code here
    String[] nums1 = version1.split("\\.");
    String[] nums2 = version2.split("\\.");

    int n1 = nums1.length, n2 = nums2.length;
    int i1, i2;
    for (int i = 0; i < Math.max(n1, n2); ++i) {
        // 两个三元运算是为了保证版本号长度不一致时有值
        // 有点像LeetCode第二题
        i1 = i < n1 ? Integer.parseInt(nums1[i]) : 0;
        i2 = i < n2 ? Integer.parseInt(nums2[i]) : 0;
        if (i1 != i2)
            return i1 > i2 ? 1 : -1;
    }
    return 0;
}
```

#### 4. 合并两个有序数组

````
两个有序数组 A, B, 将 A, B 合并成一个新的有序数组，要求时间复杂度为 O(n)。
````

```java
/**
* 基本上是 LeetCode 上的原题，只不过 LeetCode 上 A 数组比较大，是要把 B 合并到 A 上去。
* @param a int整型一维数组 升序数组
* @param b int整型一维数组 升序数组
* @return int整型一维数组
*/
public int[] Merge (int[] a, int[] b) {
    // write code here
    int lenA = a.length, lenB = b.length;
    int[] res = new int[lenA + lenB];
    int idxA = lenA - 1, idxB = lenB - 1;
    int idxC = lenA + lenB - 1;
    while ((idxA >= 0) && (idxB >= 0))
        res[idxC--] = (a[idxA] < b[idxB]) ? b[idxB--] : a[idxA--];
    System.arraycopy(b, 0, res, 0, idxB + 1);
    System.arraycopy(a, 0, res, 0, idxA + 1);
    return res;
}
```

### 设计题

```
设计一个简单的聊天室，说说单聊和多聊的设计思路。
```

